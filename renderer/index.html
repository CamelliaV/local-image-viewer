<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hanasato</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto',
          sans-serif;
      }
      .app-container {
        height: 100vh;
        overflow-y: auto;
        overflow-x: hidden;
      }
      .app-container::-webkit-scrollbar {
        width: 8px;
      }
      .app-container::-webkit-scrollbar-track {
        background: #f1f1f1;
      }
      .app-container::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 4px;
      }
      .app-container::-webkit-scrollbar-thumb:hover {
        background: #555;
      }
      .waterfall-container {
        display: flex;
        gap: 12px;
        padding: 16px;
        align-items: flex-start;
        overflow-x: auto;
      }
      .waterfall-column {
        flex: 1 0 180px;
        min-width: 180px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .image-card {
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        transition: all 0.2s ease;
        cursor: pointer;
        position: relative;
        display: flex;
        flex-direction: column;
      }
      .image-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
      }
      .image-card img {
        width: 100%;
        height: auto;
        max-height: 400px;
        object-fit: cover;
        display: block;
      }
      .placeholder-card {
        background: linear-gradient(
          90deg,
          #f0f0f0 25%,
          #e0e0e0 50%,
          #f0f0f0 75%
        );
        background-size: 200% 100%;
        animation: shimmer 1.5s infinite;
        border-radius: 12px;
        height: 200px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #999;
      }
      @keyframes shimmer {
        0% {
          background-position: -200% 0;
        }
        100% {
          background-position: 200% 0;
        }
      }
      .load-more-trigger {
        height: 100px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 20px 0;
      }
      /* Mosaic Mode Animations */
      @keyframes mosaicFadeIn {
        from { opacity: 0; transform: scale(0.95); }
        to { opacity: 1; transform: scale(1); }
      }
      @keyframes mosaicFadeOut {
        from { opacity: 1; transform: scale(1); }
        to { opacity: 0; transform: scale(0.95); }
      }
      @keyframes mosaicSlideLeft {
        from { opacity: 0; transform: translateX(100%); }
        to { opacity: 1; transform: translateX(0); }
      }
      @keyframes mosaicSlideRight {
        from { opacity: 0; transform: translateX(-100%); }
        to { opacity: 1; transform: translateX(0); }
      }
      @keyframes mosaicTileIn {
        from { opacity: 0; transform: scale(0.8) rotate(-5deg); }
        to { opacity: 1; transform: scale(1) rotate(0deg); }
      }
      .mosaic-enter { animation: mosaicFadeIn 0.4s ease-out forwards; }
      .mosaic-exit { animation: mosaicFadeOut 0.3s ease-in forwards; }
      .mosaic-slide-left { animation: mosaicSlideLeft 0.5s ease-out forwards; }
      .mosaic-slide-right { animation: mosaicSlideRight 0.5s ease-out forwards; }
      .mosaic-tile { animation: mosaicTileIn 0.4s ease-out forwards; }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script>
      console.log('Script starting - React:', typeof React, 'ReactDOM:', typeof ReactDOM)
    </script>
    <script type="text/babel">
      const { useState, useEffect, useCallback, useRef, useMemo, createContext, useContext } = React
      const BATCH_SIZE = 20
      const COLUMN_COUNT = 4

      // --- i18n System ---
      const I18nContext = createContext({ t: key => key, locale: 'en', setLocale: () => {}, availableLocales: ['en'] })

      const useI18n = () => useContext(I18nContext)

      const I18nProvider = ({ children }) => {
        const [translations, setTranslations] = useState({})
        const [locale, setLocaleState] = useState(() => localStorage.getItem('locale') || '')
        const [availableLocales, setAvailableLocales] = useState(['en'])
        const [initialized, setInitialized] = useState(false)

        useEffect(() => {
          const initLocale = async () => {
            const locales = await window.electronAPI.getAvailableLocales()
            setAvailableLocales(locales)

            let targetLocale = localStorage.getItem('locale')
            if (!targetLocale) {
              targetLocale = await window.electronAPI.getSystemLocale()
            }
            const { locale: resolvedLocale, data } = await window.electronAPI.getLocaleData(targetLocale)
            setTranslations(data)
            setLocaleState(resolvedLocale)
            setInitialized(true)
          }
          initLocale()
        }, [])

        const setLocale = useCallback(async (newLocale) => {
          const { locale: resolvedLocale, data } = await window.electronAPI.getLocaleData(newLocale)
          setTranslations(data)
          setLocaleState(resolvedLocale)
          localStorage.setItem('locale', resolvedLocale)
        }, [])

        const t = useCallback((key, params = {}) => {
          const keys = key.split('.')
          let value = translations
          for (const k of keys) {
            if (value && typeof value === 'object' && k in value) {
              value = value[k]
            } else {
              return key // Return key if translation not found
            }
          }
          if (typeof value !== 'string') return key
          // Replace {param} placeholders
          return value.replace(/\{(\w+)\}/g, (_, name) => params[name] ?? `{${name}}`)
        }, [translations])

        if (!initialized) {
          return <div className="flex items-center justify-center h-screen bg-gray-900 text-white">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
          </div>
        }

        return (
          <I18nContext.Provider value={{ t, locale, setLocale, availableLocales }}>
            {children}
          </I18nContext.Provider>
        )
      }

      const LOCALE_NAMES = {
        'en': 'English',
        'zh-CN': 'ÁÆÄ‰Ωì‰∏≠Êñá',
        'ja': 'Êó•Êú¨Ë™û'
      }

      // Stylish theme definitions
      const THEMES = {
        midnight: {
          name: 'Midnight',
          bg: 'bg-gray-950',
          bgSecondary: 'bg-gray-900',
          text: 'text-gray-100',
          textSecondary: 'text-gray-400',
          border: 'border-gray-800',
          card: 'bg-gray-900',
          accent: 'bg-violet-600 hover:bg-violet-700',
          accentText: 'text-violet-400',
          header: 'bg-gray-900/95',
          input: 'bg-gray-800 border-gray-700 text-white placeholder-gray-500',
          button: 'bg-gray-800 hover:bg-gray-700',
          gradient: 'from-violet-600 to-fuchsia-600'
        },
        sakura: {
          name: 'Sakura',
          bg: 'bg-pink-50',
          bgSecondary: 'bg-white',
          text: 'text-gray-800',
          textSecondary: 'text-pink-600',
          border: 'border-pink-200',
          card: 'bg-white',
          accent: 'bg-pink-500 hover:bg-pink-600',
          accentText: 'text-pink-500',
          header: 'bg-white/95',
          input: 'bg-white border-pink-300 text-gray-800 placeholder-pink-400',
          button: 'bg-pink-100 hover:bg-pink-200',
          gradient: 'from-pink-500 to-rose-500'
        },
        ocean: {
          name: 'Ocean',
          bg: 'bg-slate-900',
          bgSecondary: 'bg-slate-800',
          text: 'text-cyan-50',
          textSecondary: 'text-cyan-400',
          border: 'border-slate-700',
          card: 'bg-slate-800',
          accent: 'bg-cyan-500 hover:bg-cyan-600',
          accentText: 'text-cyan-400',
          header: 'bg-slate-800/95',
          input: 'bg-slate-700 border-slate-600 text-white placeholder-slate-400',
          button: 'bg-slate-700 hover:bg-slate-600',
          gradient: 'from-cyan-500 to-blue-600'
        },
        forest: {
          name: 'Forest',
          bg: 'bg-emerald-950',
          bgSecondary: 'bg-emerald-900',
          text: 'text-emerald-50',
          textSecondary: 'text-emerald-400',
          border: 'border-emerald-800',
          card: 'bg-emerald-900',
          accent: 'bg-emerald-500 hover:bg-emerald-600',
          accentText: 'text-emerald-400',
          header: 'bg-emerald-900/95',
          input: 'bg-emerald-800 border-emerald-700 text-white placeholder-emerald-500',
          button: 'bg-emerald-800 hover:bg-emerald-700',
          gradient: 'from-emerald-500 to-teal-500'
        },
        sunset: {
          name: 'Sunset',
          bg: 'bg-orange-50',
          bgSecondary: 'bg-white',
          text: 'text-gray-800',
          textSecondary: 'text-orange-600',
          border: 'border-orange-200',
          card: 'bg-white',
          accent: 'bg-orange-500 hover:bg-orange-600',
          accentText: 'text-orange-500',
          header: 'bg-white/95',
          input: 'bg-white border-orange-300 text-gray-800 placeholder-orange-400',
          button: 'bg-orange-100 hover:bg-orange-200',
          gradient: 'from-orange-500 to-amber-500'
        },
        neon: {
          name: 'Neon',
          bg: 'bg-black',
          bgSecondary: 'bg-zinc-900',
          text: 'text-white',
          textSecondary: 'text-fuchsia-400',
          border: 'border-fuchsia-900',
          card: 'bg-zinc-900',
          accent: 'bg-fuchsia-600 hover:bg-fuchsia-500',
          accentText: 'text-fuchsia-400',
          header: 'bg-zinc-900/95',
          input: 'bg-zinc-800 border-fuchsia-800 text-white placeholder-zinc-500',
          button: 'bg-zinc-800 hover:bg-zinc-700',
          gradient: 'from-fuchsia-500 to-cyan-400'
        },
        lavender: {
          name: 'Lavender',
          bg: 'bg-purple-50',
          bgSecondary: 'bg-white',
          text: 'text-gray-800',
          textSecondary: 'text-purple-600',
          border: 'border-purple-200',
          card: 'bg-white',
          accent: 'bg-purple-500 hover:bg-purple-600',
          accentText: 'text-purple-500',
          header: 'bg-white/95',
          input: 'bg-white border-purple-300 text-gray-800 placeholder-purple-400',
          button: 'bg-purple-100 hover:bg-purple-200',
          gradient: 'from-purple-500 to-indigo-500'
        },
        noir: {
          name: 'Noir',
          bg: 'bg-neutral-950',
          bgSecondary: 'bg-neutral-900',
          text: 'text-neutral-100',
          textSecondary: 'text-neutral-400',
          border: 'border-neutral-800',
          card: 'bg-neutral-900',
          accent: 'bg-neutral-700 hover:bg-neutral-600',
          accentText: 'text-neutral-300',
          header: 'bg-neutral-900/95',
          input: 'bg-neutral-800 border-neutral-700 text-white placeholder-neutral-500',
          button: 'bg-neutral-800 hover:bg-neutral-700',
          gradient: 'from-neutral-600 to-neutral-400'
        }
      }

      const DEFAULT_KEYBINDINGS = {
        // Image viewer navigation
        prevImage: 'ArrowLeft',
        nextImage: 'ArrowRight',
        closeModal: 'Escape',
        // Zoom controls
        zoomIn: '+',
        zoomOut: '-',
        resetZoom: '0',
        toggleDragMode: 'd',
        // Actions
        toggleSlideshow: ' ',
        deleteImage: 'Delete',
        starImage: 's',
        copyToClipboard: 'y',
        openLocation: 'l',
        // Edit modes
        cropImage: 'x',
        resizeImage: 'r',
        // Main window
        openDirectory: 'o',
        viewFavorites: 'f',
        toggleDeleteMode: 'Backspace',
        newTab: 't',
        closeTab: 'w',
        toggleDarkMode: 'm',
        openSettings: ',',
        openHelp: '?',
        toggleHistoryPanel: 'h',
        toggleMetadata: 'c',
        // Mosaic Mode
        toggleMosaicMode: 'g',
        mosaicNextWall: 'ArrowRight',
        mosaicPrevWall: 'ArrowLeft',
        mosaicResetTileScale: 'r',
        mosaicToggleDrawer: 'c'
      }

      const KEYBINDING_LABELS = {
        prevImage: 'keybindingLabels.prevImage',
        nextImage: 'keybindingLabels.nextImage',
        closeModal: 'keybindingLabels.closeModal',
        zoomIn: 'keybindingLabels.zoomIn',
        zoomOut: 'keybindingLabels.zoomOut',
        resetZoom: 'keybindingLabels.resetZoom',
        toggleDragMode: 'keybindingLabels.toggleDragMode',
        toggleSlideshow: 'keybindingLabels.toggleSlideshow',
        deleteImage: 'keybindingLabels.deleteImage',
        starImage: 'keybindingLabels.starImage',
        copyToClipboard: 'keybindingLabels.copyToClipboard',
        openLocation: 'keybindingLabels.openLocation',
        cropImage: 'keybindingLabels.cropImage',
        resizeImage: 'keybindingLabels.resizeImage',
        openDirectory: 'keybindingLabels.openDirectory',
        viewFavorites: 'keybindingLabels.viewFavorites',
        toggleDeleteMode: 'keybindingLabels.toggleDeleteMode',
        newTab: 'keybindingLabels.newTab',
        closeTab: 'keybindingLabels.closeTab',
        toggleDarkMode: 'keybindingLabels.toggleDarkMode',
        openSettings: 'keybindingLabels.openSettings',
        openHelp: 'keybindingLabels.openHelp',
        toggleHistoryPanel: 'keybindingLabels.toggleHistoryPanel',
        toggleMetadata: 'keybindingLabels.toggleMetadata',
        toggleMosaicMode: 'keybindingLabels.toggleMosaicMode',
        mosaicNextWall: 'keybindingLabels.mosaicNextWall',
        mosaicPrevWall: 'keybindingLabels.mosaicPrevWall',
        mosaicResetTileScale: 'keybindingLabels.mosaicResetTileScale',
        mosaicToggleDrawer: 'keybindingLabels.mosaicToggleDrawer'
      }

      const formatKey = key => key === ' ' ? 'Space' : key

      const formatFileSize = bytes => {
        if (bytes === 0) return '0 Bytes'
        const k = 1024
        const sizes = ['Bytes', 'KB', 'MB', 'GB']
        const i = Math.floor(Math.log(bytes) / Math.log(k))
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
      }

      const ImageCard = React.memo(
        ({
          image,
          onImageClick,
          onToggleSelection,
          onStar,
          deleteMode,
          theme,
          isSelected,
          showStarButton,
          onContextMenu,
          starVersion,
          retainImages
        }) => {
          const { t } = useI18n()
          const [imageLoaded, setImageLoaded] = useState(() => retainImages && loadedImagesCache.has(image.fullPath))
          const [imageError, setImageError] = useState(false)
          const [isStarred, setIsStarred] = useState(false)
          const handleImageLoad = useCallback(() => {
            setImageLoaded(true)
            if (retainImages) loadedImagesCache.add(image.fullPath)
          }, [image.fullPath, retainImages])
          const handleImageError = useCallback(() => setImageError(true), [])
          const handleClick = useCallback(() => {
            if (deleteMode) {
              onToggleSelection(image)
            } else {
              onImageClick(image)
            }
          }, [deleteMode, image, onToggleSelection, onImageClick])

          useEffect(() => {
            window.electronAPI.isImageStarred(image.fullPath).then(setIsStarred)
          }, [image.fullPath, starVersion])

          const handleStar = useCallback(async e => {
            e.stopPropagation()
            await onStar(image)
            const starred = await window.electronAPI.isImageStarred(image.fullPath)
            setIsStarred(starred)
          }, [image, onStar])

          if (imageError) {
            return (
              <div
                className={`image-card ${theme.card}`}
                style={{ height: '150px' }}
              >
                <div className={`h-full flex flex-col items-center justify-center ${theme.textSecondary}`}>
                  <div className="text-2xl mb-2">‚ùå</div>
                  <div className="text-sm">{t('app.failedToLoad')}</div>
                </div>
              </div>
            )
          }

          const handleContextMenuEvent = useCallback(e => {
            e.preventDefault()
            onContextMenu(e, image)
          }, [image, onContextMenu])

          return (
            <div
              className={`image-card group ${theme.card}`}
              onClick={handleClick}
              onContextMenu={handleContextMenuEvent}
            >
              {!imageLoaded && (
                <div className="placeholder-card">
                  <div className="text-center">
                    <div className="text-2xl mb-2">üñºÔ∏è</div>
                    <div className="text-sm">{t('app.loading')}</div>
                  </div>
                </div>
              )}
              <div
                className={`relative transition-all duration-200 ${
                  isSelected ? 'ring-4 ring-blue-500' : ''
                }`}
              >
                <img
                  src={image.url}
                  alt={image.name}
                  onLoad={handleImageLoad}
                  onError={handleImageError}
                  className={`transition-opacity duration-300 ${
                    imageLoaded ? 'opacity-100' : 'opacity-0 absolute inset-0'
                  }`}
                />
                {isSelected && (
                  <div className="absolute inset-0 bg-blue-500 bg-opacity-40 flex items-center justify-center text-white text-4xl font-bold">
                    ‚úì
                  </div>
                )}
                {showStarButton && !deleteMode && (
                  <button
                    onClick={handleStar}
                    className={`absolute top-2 right-2 bg-black bg-opacity-50 p-1.5 rounded-full transition-opacity hover:bg-opacity-70 ${isStarred ? 'opacity-100 text-yellow-400' : 'opacity-0 group-hover:opacity-100 text-gray-400'}`}
                    title={isStarred ? t('star.unstarImage') : t('star.starImage')}
                  >
                    {isStarred ? '‚≠ê' : '‚òÜ'}
                  </button>
                )}
              </div>
              <div className="p-2 text-left">
                <div className="font-medium text-sm truncate">{image.name}</div>
                <div className={`text-xs ${theme.textSecondary}`}>
                  {formatFileSize(image.size)}
                </div>
              </div>
            </div>
          )
        }
      )

      const loadedImagesCache = new Set()

      const WaterfallGrid = React.memo(
        ({
          displayedImages,
          onImageClick,
          onToggleSelection,
          onStar,
          deleteMode,
          theme,
          isSelected,
          loadMoreObserverRef,
          loadingMore,
          hasMore,
          filteredImagesCount,
          columnCount,
          showStarButton,
          onContextMenu,
          starVersion,
          retainImages
        }) => {
          const { t } = useI18n()
          const columns = useMemo(() => {
            const cols = Array.from({ length: columnCount }, () => [])
            displayedImages.forEach((image, index) => {
              cols[index % columnCount].push(image)
            })
            return cols
          }, [displayedImages, columnCount])
          return (
            <div>
              <div className="waterfall-container">
                {columns.map((columnImages, columnIndex) => (
                  <div key={columnIndex} className="waterfall-column">
                    {columnImages.map(image => (
                      <ImageCard
                        key={image.fullPath}
                        image={image}
                        onImageClick={onImageClick}
                        onToggleSelection={onToggleSelection}
                        onStar={onStar}
                        deleteMode={deleteMode}
                        theme={theme}
                        isSelected={isSelected(image)}
                        showStarButton={showStarButton}
                        onContextMenu={onContextMenu}
                        starVersion={starVersion}
                        retainImages={retainImages}
                      />
                    ))}
                  </div>
                ))}
              </div>
              {hasMore && (
                <div ref={loadMoreObserverRef} className="load-more-trigger">
                  {loadingMore ? (
                    <div className="flex items-center gap-2">
                      <div className={`animate-spin rounded-full h-6 w-6 border-b-2 ${theme.accentText.replace('text-', 'border-')}`}></div>
                      <span>{t('images.loadingMore')}</span>
                    </div>
                  ) : (
                    <div className={theme.textSecondary}>{t('images.loadingMore')}</div>
                  )}
                </div>
              )}
              {!hasMore && displayedImages.length > 0 && (
                <div className={`text-center py-8 ${theme.textSecondary}`}>
                  üéâ {t('images.allImagesLoaded', { count: filteredImagesCount })}
                </div>
              )}
            </div>
          )
        }
      )

      const ImageModal = React.memo(
        ({
          selectedImage,
          filteredImages,
          onClose,
          onDelete,
          onOpenLocation,
          onNavigate,
          onStar,
          keybindings,
          clickOutsideToClose,
          showActionFeedback,
          maxImageSize,
          fromMosaicMode
        }) => {
          const { t } = useI18n()
          const [zoom, setZoom] = useState(1)
          const [position, setPosition] = useState({ x: 0, y: 0 })
          const [isDragging, setIsDragging] = useState(false)
          const [dragMode, setDragMode] = useState(false)
          const dragStartRef = useRef({ x: 0, y: 0 })
          const positionRef = useRef({ x: 0, y: 0 })
          const zoomRef = useRef(1)
          const [dimensions, setDimensions] = useState(null)
          const [slideshow, setSlideshow] = useState(false)
          const [editMode, setEditMode] = useState(null) // 'crop' | 'resize' | null
          const [cropArea, setCropArea] = useState(null)
          const [resizeW, setResizeW] = useState('')
          const [resizeH, setResizeH] = useState('')
          const [contextMenu, setContextMenu] = useState(null)
          const [showMetadata, setShowMetadata] = useState(() => localStorage.getItem('imageViewerShowMetadata') !== 'false')
          const imageRef = useRef(null)
          const canvasRef = useRef(null)

          // Save metadata preference
          useEffect(() => {
            localStorage.setItem('imageViewerShowMetadata', showMetadata.toString())
          }, [showMetadata])

          useEffect(() => {
            setZoom(1)
            zoomRef.current = 1
            setPosition({ x: 0, y: 0 })
            positionRef.current = { x: 0, y: 0 }
            setDimensions(null)
            setEditMode(null)
            setDragMode(false)
            setCropArea(null)
            setContextMenu(null)
          }, [selectedImage?.fullPath])

          const currentIndex = useMemo(
            () =>
              selectedImage
                ? filteredImages.findIndex(
                    img => img.fullPath === selectedImage.fullPath
                  )
                : -1,
            [filteredImages, selectedImage]
          )

          useEffect(() => {
            if (!slideshow || !selectedImage) return
            const timer = setInterval(() => {
              if (currentIndex < filteredImages.length - 1) {
                onNavigate(filteredImages[currentIndex + 1])
              } else {
                onNavigate(filteredImages[0])
              }
            }, 3000)
            return () => clearInterval(timer)
          }, [slideshow, selectedImage, filteredImages, onNavigate, currentIndex])

          const showPrevious = useCallback(() => {
            if (currentIndex > 0) onNavigate(filteredImages[currentIndex - 1])
          }, [currentIndex, filteredImages, onNavigate])
          const showNext = useCallback(() => {
            if (currentIndex < filteredImages.length - 1)
              onNavigate(filteredImages[currentIndex + 1])
          }, [currentIndex, filteredImages, onNavigate])

          const handleWheel = useCallback(e => {
            e.preventDefault()
            const delta = e.deltaY > 0 ? 0.9 : 1.1
            setZoom(z => {
              const newZoom = Math.min(Math.max(z * delta, 0.5), 5)
              zoomRef.current = newZoom
              return newZoom
            })
          }, [])

          const handleMouseDown = useCallback(e => {
            // Allow drag when in drag mode (no zoom requirement)
            if (dragMode && !editMode) {
              e.preventDefault()
              e.stopPropagation()
              setIsDragging(true)
              dragStartRef.current = { x: e.clientX - positionRef.current.x, y: e.clientY - positionRef.current.y }
            }
          }, [editMode, dragMode])

          const handleMouseMove = useCallback(e => {
            if (isDragging) {
              const newPos = { x: e.clientX - dragStartRef.current.x, y: e.clientY - dragStartRef.current.y }
              positionRef.current = newPos
              setPosition(newPos)
            }
          }, [isDragging])

          const handleMouseUp = useCallback(() => {
            setIsDragging(false)
          }, [])

          const handleContextMenu = useCallback(e => {
            e.preventDefault()
            setContextMenu({ x: e.clientX, y: e.clientY })
          }, [])

          const closeContextMenu = useCallback(() => setContextMenu(null), [])

          const handleCropStart = useCallback(e => {
            if (editMode !== 'crop' || !imageRef.current) return
            const rect = imageRef.current.getBoundingClientRect()
            const x = e.clientX - rect.left
            const y = e.clientY - rect.top
            setCropArea({ x, y, w: 0, h: 0, startX: x, startY: y })
          }, [editMode])

          const handleCropMove = useCallback(e => {
            if (!cropArea?.startX || !imageRef.current) return
            const rect = imageRef.current.getBoundingClientRect()
            const x = Math.max(0, Math.min(e.clientX - rect.left, rect.width))
            const y = Math.max(0, Math.min(e.clientY - rect.top, rect.height))
            setCropArea(prev => ({
              ...prev,
              x: Math.min(prev.startX, x),
              y: Math.min(prev.startY, y),
              w: Math.abs(x - prev.startX),
              h: Math.abs(y - prev.startY)
            }))
          }, [cropArea])

          const handleCropEnd = useCallback(() => {
            if (cropArea) setCropArea(prev => ({ ...prev, startX: null, startY: null }))
          }, [cropArea])

          const saveCrop = useCallback(async () => {
            if (!cropArea || !dimensions || !imageRef.current) return
            const rect = imageRef.current.getBoundingClientRect()
            const scaleX = dimensions.w / rect.width
            const scaleY = dimensions.h / rect.height
            const canvas = document.createElement('canvas')
            canvas.width = cropArea.w * scaleX
            canvas.height = cropArea.h * scaleY
            const ctx = canvas.getContext('2d')
            const img = new Image()
            img.crossOrigin = 'anonymous'
            img.onload = async () => {
              ctx.drawImage(img, cropArea.x * scaleX, cropArea.y * scaleY, canvas.width, canvas.height, 0, 0, canvas.width, canvas.height)
              const dataUrl = canvas.toDataURL('image/png')
              try {
                await window.electronAPI.saveEditedImage(selectedImage.fullPath, dataUrl, 'cropped')
                alert(t('prompts.croppedImageSaved'))
                setEditMode(null)
                setCropArea(null)
              } catch (err) { alert(t('prompts.error') + ': ' + err.message) }
            }
            img.src = selectedImage.url.replace('local-image://', 'file://')
          }, [cropArea, dimensions, selectedImage, t])

          const saveResize = useCallback(async () => {
            if (!resizeW || !resizeH || !dimensions) return
            const canvas = document.createElement('canvas')
            canvas.width = parseInt(resizeW)
            canvas.height = parseInt(resizeH)
            const ctx = canvas.getContext('2d')
            const img = new Image()
            img.crossOrigin = 'anonymous'
            img.onload = async () => {
              ctx.drawImage(img, 0, 0, canvas.width, canvas.height)
              const dataUrl = canvas.toDataURL('image/png')
              try {
                await window.electronAPI.saveEditedImage(selectedImage.fullPath, dataUrl, `${canvas.width}x${canvas.height}`)
                alert(t('prompts.resizedImageSaved'))
                setEditMode(null)
              } catch (err) { alert(t('prompts.error') + ': ' + err.message) }
            }
            img.src = selectedImage.url.replace('local-image://', 'file://')
          }, [resizeW, resizeH, dimensions, selectedImage, t])

          useEffect(() => {
            if (!selectedImage) return
            const handleKeyPress = async e => {
              const key = e.key
              if (key === keybindings.closeModal) onClose()
              else if (key === keybindings.prevImage) showPrevious()
              else if (key === keybindings.nextImage) showNext()
              else if (key === keybindings.zoomIn || key === '=') setZoom(z => { const nz = Math.min(z * 1.2, 5); zoomRef.current = nz; return nz })
              else if (key === keybindings.zoomOut) setZoom(z => { const nz = Math.max(z / 1.2, 0.5); zoomRef.current = nz; return nz })
              else if (key === keybindings.resetZoom) { setZoom(1); zoomRef.current = 1; setPosition({ x: 0, y: 0 }); positionRef.current = { x: 0, y: 0 }; setDragMode(false) }
              else if (key === keybindings.toggleDragMode || key === 'D') { setDragMode(d => !d) }
              else if (key === keybindings.toggleSlideshow) { e.preventDefault(); setSlideshow(s => !s) }
              else if (key === keybindings.deleteImage) { onDelete([selectedImage.fullPath]) }
              else if (key === keybindings.starImage || key === 'S') { onStar(selectedImage) }
              else if (key === keybindings.copyToClipboard) {
                try {
                  await window.electronAPI.copyImageToClipboard(selectedImage.fullPath)
                  if (showActionFeedback) alert(t('prompts.copied'))
                } catch (err) { alert(t('prompts.error') + ': ' + err.message) }
              }
              else if (key === keybindings.openLocation || key === 'L') { onOpenLocation(selectedImage) }
              else if (key === keybindings.cropImage || key === 'X') { setEditMode(editMode === 'crop' ? null : 'crop'); setCropArea(null) }
              else if (key === keybindings.resizeImage || key === 'R') { setEditMode(editMode === 'resize' ? null : 'resize'); if (dimensions) { setResizeW(String(dimensions.w)); setResizeH(String(dimensions.h)) } }
              else if (key === keybindings.toggleMetadata || key === keybindings.mosaicToggleDrawer) { setShowMetadata(v => !v) }
            }
            document.addEventListener('keydown', handleKeyPress)
            return () => document.removeEventListener('keydown', handleKeyPress)
          }, [onClose, showPrevious, showNext, selectedImage, keybindings, onDelete, onStar, onOpenLocation, showActionFeedback, editMode, dimensions])

          if (!selectedImage) return null

          const handleBackdropClick = e => {
            if (contextMenu) {
              setContextMenu(null)
              return
            }
            if (clickOutsideToClose && e.target === e.currentTarget && zoomRef.current <= 1) {
              onClose()
            }
          }

          return (
            <div
              className="fixed inset-0 backdrop-blur-md bg-black/70 flex items-center justify-center z-50"
              onMouseMove={handleMouseMove}
              onMouseUp={handleMouseUp}
              onMouseLeave={handleMouseUp}
              onMouseDown={handleMouseDown}
              onClick={handleBackdropClick}
            >
              <div className="relative w-full h-full flex items-center justify-center p-4" onClick={handleBackdropClick}>
                <div className="relative" onMouseDown={editMode === 'crop' ? handleCropStart : undefined} onMouseMove={editMode === 'crop' ? handleCropMove : undefined} onMouseUp={editMode === 'crop' ? handleCropEnd : undefined} onMouseLeave={editMode === 'crop' ? handleCropEnd : undefined} onClick={e => e.stopPropagation()}>
                  <img
                    ref={imageRef}
                    src={selectedImage.url}
                    alt={selectedImage.name}
                    className="object-contain select-none"
                    style={{
                      maxWidth: `${maxImageSize}vw`,
                      maxHeight: `${maxImageSize - 5}vh`,
                      transform: editMode ? 'none' : `scale(${zoom}) translate(${position.x / zoom}px, ${position.y / zoom}px)`,
                      cursor: editMode === 'crop' ? 'crosshair' : (dragMode ? (isDragging ? 'grabbing' : 'grab') : 'default'),
                      transition: isDragging ? 'none' : 'transform 0.1s ease-out'
                    }}
                    onWheel={editMode ? undefined : handleWheel}
                    onMouseDown={editMode ? undefined : handleMouseDown}
                    onLoad={e => setDimensions({ w: e.target.naturalWidth, h: e.target.naturalHeight })}
                    draggable={false}
                    onContextMenu={handleContextMenu}
                  />
                  {editMode === 'crop' && cropArea && (
                    <div
                      className="absolute border-2 border-dashed border-white bg-white bg-opacity-20 pointer-events-none"
                      style={{ left: cropArea.x, top: cropArea.y, width: cropArea.w, height: cropArea.h }}
                    />
                  )}
                </div>

                {contextMenu && (
                  <div
                    className="fixed backdrop-blur-xl bg-black/60 border border-white/20 rounded-xl shadow-2xl py-2 z-[60] min-w-[180px]"
                    style={{ left: contextMenu.x, top: contextMenu.y }}
                    onClick={closeContextMenu}
                  >
                    <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => onDelete([selectedImage.fullPath])}>{t('actions.delete')}</button>
                    <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => onOpenLocation(selectedImage)}>{t('contextMenu.openLocation')}</button>
                    <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={async () => { await window.electronAPI.copyImageToClipboard(selectedImage.fullPath); if (showActionFeedback) alert(t('prompts.copied')) }}>{t('viewer.copyToClipboard')}</button>
                    <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => onStar(selectedImage)}>{t('star.starUnstar')}</button>
                    <div className="border-t border-white/20 my-1"></div>
                    <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => setSlideshow(s => !s)}>{slideshow ? t('viewer.stopSlideshow') : t('viewer.startSlideshow')}</button>
                    <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => { setEditMode('crop'); setCropArea(null) }}>{t('viewer.crop')}</button>
                    <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => { setEditMode('resize'); if (dimensions) { setResizeW(String(dimensions.w)); setResizeH(String(dimensions.h)) } }}>{t('viewer.resize')}</button>
                    <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => {
                      const newName = prompt(t('prompts.enterNewFilename'), selectedImage.name)
                      if (newName && newName !== selectedImage.name) {
                        window.electronAPI.renameImage(selectedImage.fullPath, newName).then(() => { if (showActionFeedback) alert(t('prompts.fileCopiedNewName')) }).catch(err => alert(t('prompts.error') + ': ' + err.message))
                      }
                    }}>{t('actions.saveAs')}</button>
                    <div className="border-t border-white/20 my-1"></div>
                    <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => { setZoom(z => { const nz = Math.min(z * 1.2, 5); zoomRef.current = nz; return nz }) }}>{t('viewer.zoomIn')}</button>
                    <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => { setZoom(z => { const nz = Math.max(z / 1.2, 0.5); zoomRef.current = nz; return nz }) }}>{t('viewer.zoomOut')}</button>
                    <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => { setZoom(1); zoomRef.current = 1; setPosition({ x: 0, y: 0 }); positionRef.current = { x: 0, y: 0 }; setDragMode(false) }}>{t('viewer.resetZoom')}</button>
                    <button className={`w-full px-4 py-2 text-left text-sm transition-colors ${dragMode ? 'text-cyan-400 bg-white/5' : 'text-white'} hover:bg-white/10`} onClick={() => setDragMode(d => !d)}>{dragMode ? '‚úì ' + t('viewer.dragModeOn') : t('viewer.enableDragMode')}</button>
                    <div className="border-t border-white/20 my-1"></div>
                    <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={onClose}>{t('actions.close')}</button>
                  </div>
                )}

                <button
                  onClick={onClose}
                  className="absolute top-4 right-4 bg-black bg-opacity-60 text-white p-2 rounded-full hover:bg-opacity-80 transition-all text-xl"
                  title={t('viewer.closeEsc')}
                >
                  ‚úï
                </button>
                <button
                  onClick={() => onDelete([selectedImage.fullPath])}
                  className="absolute top-4 left-4 bg-red-500 bg-opacity-80 text-white p-2 rounded-full hover:bg-opacity-100 transition-all"
                  title={t('viewer.deleteImage')}
                >
                  üóëÔ∏è
                </button>
                <button
                  onClick={() => onOpenLocation(selectedImage)}
                  className="absolute top-16 left-4 bg-blue-500 bg-opacity-80 text-white p-2 rounded-full hover:bg-opacity-100 transition-all"
                  title={t('viewer.openFileLocation')}
                >
                  üìÅ
                </button>
                <button
                  onClick={async () => {
                    try {
                      await window.electronAPI.copyImageToClipboard(selectedImage.fullPath)
                      if (showActionFeedback) alert(t('prompts.imageCopiedToClipboard'))
                    } catch (err) { alert(t('prompts.error') + ': ' + err.message) }
                  }}
                  className="absolute top-16 left-16 bg-indigo-500 bg-opacity-80 text-white p-2 rounded-full hover:bg-opacity-100 transition-all"
                  title={t('viewer.copyToClipboard')}
                >
                  üìã
                </button>
                <button
                  onClick={() => onStar(selectedImage)}
                  className="absolute top-28 left-4 bg-yellow-400 bg-opacity-80 text-white p-2 rounded-full hover:bg-opacity-100 transition-all text-lg"
                  title={t('viewer.copyToStarred')}
                >
                  ‚≠ê
                </button>
                <button
                  onClick={() => setSlideshow(s => !s)}
                  className={`absolute top-40 left-4 ${slideshow ? 'bg-green-500' : 'bg-gray-500'} bg-opacity-80 text-white p-2 rounded-full hover:bg-opacity-100 transition-all`}
                  title={t('viewer.slideshow') + ' (Space)'}
                >
                  {slideshow ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è'}
                </button>
                <button
                  onClick={() => setDragMode(d => !d)}
                  className={`absolute top-40 left-16 ${dragMode ? 'bg-cyan-500' : 'bg-gray-500'} bg-opacity-80 text-white p-2 rounded-full hover:bg-opacity-100 transition-all`}
                  title={dragMode ? t('viewer.dragModeOn') : t('viewer.enableDragMode')}
                >
                  ‚úã
                </button>
                <button
                  onClick={() => { setEditMode(editMode === 'crop' ? null : 'crop'); setCropArea(null) }}
                  className={`absolute top-52 left-4 ${editMode === 'crop' ? 'bg-purple-500' : 'bg-gray-500'} bg-opacity-80 text-white p-2 rounded-full hover:bg-opacity-100 transition-all`}
                  title={t('viewer.crop')}
                >
                  ‚úÇÔ∏è
                </button>
                <button
                  onClick={() => { setEditMode(editMode === 'resize' ? null : 'resize'); if (dimensions) { setResizeW(String(dimensions.w)); setResizeH(String(dimensions.h)) } }}
                  className={`absolute top-64 left-4 ${editMode === 'resize' ? 'bg-purple-500' : 'bg-gray-500'} bg-opacity-80 text-white p-2 rounded-full hover:bg-opacity-100 transition-all`}
                  title={t('viewer.resize')}
                >
                  üìê
                </button>
                <button
                  onClick={() => {
                    const newName = prompt(t('prompts.enterNewFilename'), selectedImage.name)
                    if (newName && newName !== selectedImage.name) {
                      window.electronAPI.renameImage(selectedImage.fullPath, newName)
                        .then(result => {
                          alert(t('prompts.fileRenamedSuccess'))
                          onClose()
                        })
                        .catch(err => alert(t('prompts.error') + ': ' + err.message))
                    }
                  }}
                  className="absolute top-[19rem] left-4 bg-gray-500 bg-opacity-80 text-white p-2 rounded-full hover:bg-opacity-100 transition-all"
                  title={t('viewer.rename')}
                >
                  ‚úèÔ∏è
                </button>

                {editMode === 'crop' && cropArea && cropArea.w > 10 && cropArea.h > 10 && (
                  <button
                    onClick={saveCrop}
                    className="absolute top-52 left-16 bg-green-500 text-white px-3 py-1 rounded hover:bg-green-600"
                  >
                    {t('actions.saveCrop')}
                  </button>
                )}

                {editMode === 'resize' && (
                  <div className="absolute top-64 left-16 bg-black bg-opacity-80 p-2 rounded flex items-center gap-2">
                    <input type="number" value={resizeW} onChange={e => setResizeW(e.target.value)} className="w-16 px-1 rounded text-black" placeholder="W" />
                    <span className="text-white">√ó</span>
                    <input type="number" value={resizeH} onChange={e => setResizeH(e.target.value)} className="w-16 px-1 rounded text-black" placeholder="H" />
                    <button onClick={saveResize} className="bg-green-500 text-white px-2 py-1 rounded hover:bg-green-600">{t('actions.save')}</button>
                  </div>
                )}

                <div className="absolute bottom-24 right-4 flex flex-col gap-2">
                  <button
                    onClick={() => setZoom(z => { const nz = Math.min(z * 1.2, 5); zoomRef.current = nz; return nz })}
                    className="bg-black bg-opacity-60 text-white p-2 rounded-full hover:bg-opacity-80 transition-all"
                    title={t('viewer.zoomIn') + ' (+)'}
                  >
                    üîç+
                  </button>
                  <button
                    onClick={() => setZoom(z => { const nz = Math.max(z / 1.2, 0.5); zoomRef.current = nz; return nz })}
                    className="bg-black bg-opacity-60 text-white p-2 rounded-full hover:bg-opacity-80 transition-all"
                    title={t('viewer.zoomOut') + ' (-)'}
                  >
                    üîç-
                  </button>
                  <button
                    onClick={() => { setZoom(1); zoomRef.current = 1; setPosition({ x: 0, y: 0 }); positionRef.current = { x: 0, y: 0 }; setDragMode(false) }}
                    className="bg-black bg-opacity-60 text-white p-2 rounded-full hover:bg-opacity-80 transition-all text-sm"
                    title={t('viewer.resetZoom') + ' (0)'}
                  >
                    1:1
                  </button>
                  {zoom !== 1 && (
                    <div className="bg-black bg-opacity-60 text-white px-2 py-1 rounded text-xs text-center">
                      {Math.round(zoom * 100)}%
                    </div>
                  )}
                </div>

                {currentIndex > 0 && (
                  <button
                    onClick={showPrevious}
                    className="absolute left-4 top-1/2 transform -translate-y-1/2 bg-black bg-opacity-60 text-white p-3 rounded-full hover:bg-opacity-80 transition-all text-2xl"
                    title={t('viewer.previousImage')}
                  >
                    ‚Üê
                  </button>
                )}
                {currentIndex < filteredImages.length - 1 && (
                  <button
                    onClick={showNext}
                    className="absolute right-4 top-1/2 transform -translate-y-1/2 bg-black bg-opacity-60 text-white p-3 rounded-full hover:bg-opacity-80 transition-all text-2xl"
                    title={t('viewer.nextImage')}
                  >
                    ‚Üí
                  </button>
                )}
                {/* Metadata toggle button */}
                <button
                  onClick={() => setShowMetadata(v => !v)}
                  className={`absolute bottom-4 right-4 ${showMetadata ? 'bg-white/30' : 'bg-black/60'} text-white p-2 rounded-full hover:bg-white/40 transition-all z-10`}
                  title={showMetadata ? t('viewer.hideMetadata') : t('viewer.showMetadata')}
                >
                  {showMetadata ? '‚ñº' : '‚ñ≤'}
                </button>
                {/* Metadata panel */}
                <div
                  className={`absolute bottom-4 left-4 right-16 bg-black bg-opacity-70 text-white p-4 rounded-lg backdrop-blur-sm transition-all duration-200 ${
                    showMetadata ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-4 pointer-events-none'
                  }`}
                >
                  <div className="font-medium text-lg mb-2">
                    {selectedImage.name}
                  </div>
                  <div className="text-gray-300 mb-1">{selectedImage.path}</div>
                  <div className="flex justify-between text-sm text-gray-400 flex-wrap gap-2">
                    <span>{formatFileSize(selectedImage.size)}</span>
                    {dimensions && <span>{dimensions.w} √ó {dimensions.h}</span>}
                    <span>
                      {t('viewer.modified')}:{' '}
                      {new Date(
                        selectedImage.lastModified
                      ).toLocaleDateString()}
                    </span>
                  </div>
                  <div className="text-xs text-gray-500 mt-1">
                    {currentIndex + 1} {t('viewer.of')} {filteredImages.length}
                  </div>
                </div>
              </div>
            </div>
          )
        }
      )

      // Mosaic Mode Component - Smart wall-filling gallery view
      const MosaicMode = React.memo(({
        images,
        onClose,
        onImageClick,
        keybindings,
        enableAnimation,
        mosaicAnimationType,
        mosaicAnimationDuration,
        mosaicTileSize,
        setMosaicTileSize,
        mosaicImageCount,
        setMosaicImageCount,
        mosaicControlMode,
        currentWall,
        setCurrentWall,
        mosaicLoopWalls,
        selectedImage
      }) => {
        const { t } = useI18n()
        const [displayedWall, setDisplayedWall] = useState(currentWall)
        const [nextWall, setNextWall] = useState(null)
        const [isTransitioning, setIsTransitioning] = useState(false)
        const [transitionPhase, setTransitionPhase] = useState(null) // 'out' | 'in'
        const [isExiting, setIsExiting] = useState(false)
        const [isEntering, setIsEntering] = useState(true)
        const containerRef = useRef(null)
        const [containerSize, setContainerSize] = useState({ width: 0, height: 0 })
        const [hoveredTile, setHoveredTile] = useState(null) // Track which tile is hovered
        const [tileScales, setTileScales] = useState({}) // Individual tile scale factors
        const [drawerOpen, setDrawerOpen] = useState(true) // Drawer state
        const [imageDimensions, setImageDimensions] = useState({}) // Track loaded image dimensions
        const [layoutMode, setLayoutMode] = useState(() => localStorage.getItem('mosaicLayoutMode') || 'fixed') // 'fixed' or 'adaptive'

        // Save layout mode preference
        useEffect(() => {
          localStorage.setItem('mosaicLayoutMode', layoutMode)
        }, [layoutMode])

        // Calculate container size - use window size as fallback
        useEffect(() => {
          const updateSize = () => {
            setContainerSize({
              width: window.innerWidth,
              height: window.innerHeight
            })
          }
          updateSize()
          window.addEventListener('resize', updateSize)
          return () => window.removeEventListener('resize', updateSize)
        }, [])

        // Entry animation
        useEffect(() => {
          if (enableAnimation) {
            requestAnimationFrame(() => {
              setIsEntering(false)
            })
          } else {
            setIsEntering(false)
          }
        }, [enableAnimation])

        // Lazy load image dimensions in background - don't block rendering
        useEffect(() => {
          let cancelled = false

          // Load images in small batches to avoid overwhelming the browser
          const loadBatch = async (startIdx, batchSize = 10) => {
            if (cancelled || startIdx >= images.length) return

            const batch = images.slice(startIdx, startIdx + batchSize)
            const loadedDims = {}

            await Promise.all(batch.map(img => {
              return new Promise((resolve) => {
                // Skip if already loaded
                if (imageDimensions[img.fullPath]) {
                  resolve()
                  return
                }

                const image = new Image()
                const timeout = setTimeout(() => {
                  loadedDims[img.fullPath] = { width: 1600, height: 900 }
                  resolve()
                }, 3000)

                image.onload = () => {
                  clearTimeout(timeout)
                  loadedDims[img.fullPath] = { width: image.naturalWidth, height: image.naturalHeight }
                  resolve()
                }
                image.onerror = () => {
                  clearTimeout(timeout)
                  loadedDims[img.fullPath] = { width: 1600, height: 900 }
                  resolve()
                }
                image.src = img.url
              })
            }))

            if (!cancelled && Object.keys(loadedDims).length > 0) {
              setImageDimensions(prev => ({ ...prev, ...loadedDims }))
            }

            // Continue with next batch
            if (!cancelled) {
              setTimeout(() => loadBatch(startIdx + batchSize), 50)
            }
          }

          if (images.length > 0) {
            loadBatch(0)
          }

          return () => { cancelled = true }
        }, [images])

        // Creative justified gallery layout algorithm
        const walls = useMemo(() => {
          if (!containerSize.width || !containerSize.height || images.length === 0) return []

          const wallWidth = containerSize.width - 32 // padding
          const drawerHeight = drawerOpen ? 140 : 0 // Completely hidden when collapsed
          const wallHeight = containerSize.height - drawerHeight - 16 // space for controls
          const gap = 4

          // Calculate targetRowHeight based on control mode
          let targetRowHeight
          if (mosaicControlMode === 'imageCount') {
            // Estimate row height to achieve desired image count per wall
            // Assuming average aspect ratio of 1.5 and roughly square-ish layout
            const avgAspect = 1.5
            const wallArea = wallWidth * wallHeight
            const targetTileArea = wallArea / mosaicImageCount
            // For justified layout, row height determines density
            // Smaller row height = more images per wall
            targetRowHeight = Math.sqrt(targetTileArea / avgAspect)
            // Clamp to reasonable range
            targetRowHeight = Math.max(80, Math.min(400, targetRowHeight))
          } else {
            targetRowHeight = mosaicTileSize
          }

          // Sanity check
          if (wallWidth <= 0 || wallHeight <= 0 || targetRowHeight <= 0) return []

          const result = []
          let imageIndex = 0

          // Get aspect ratio for an image
          const getAspectRatio = (img) => {
            const dims = imageDimensions[img.fullPath]
            if (dims && dims.width && dims.height) {
              return dims.width / dims.height
            }
            // Default aspect ratio
            return 1.5
          }

          if (layoutMode === 'fixed') {
            // Fixed grid layout - tiles fill the entire screen
            let cols, rows, imagesPerWall

            if (mosaicControlMode === 'imageCount') {
              // Calculate grid based on desired image count per wall
              imagesPerWall = mosaicImageCount
              // Find optimal cols/rows ratio based on screen aspect ratio
              const screenAspect = wallWidth / wallHeight
              // Try to make tiles roughly square
              cols = Math.max(1, Math.round(Math.sqrt(imagesPerWall * screenAspect)))
              rows = Math.max(1, Math.ceil(imagesPerWall / cols))
              // Adjust cols if we have too many rows
              while (cols * rows < imagesPerWall && cols < imagesPerWall) {
                cols++
                rows = Math.ceil(imagesPerWall / cols)
              }
            } else {
              // Calculate how many tiles fit at the target size
              const targetSize = mosaicTileSize
              cols = Math.max(1, Math.floor((wallWidth + gap) / (targetSize + gap)))
              rows = Math.max(1, Math.floor((wallHeight + gap) / (targetSize + gap)))
              imagesPerWall = cols * rows
            }

            // Calculate tile size to fill the entire available space
            const tileWidth = (wallWidth - (cols - 1) * gap) / cols
            const tileHeight = (wallHeight - (rows - 1) * gap) / rows

            while (imageIndex < images.length) {
              const layout = []
              const wallImages = images.slice(imageIndex, imageIndex + imagesPerWall)

              wallImages.forEach((img, idx) => {
                const col = idx % cols
                const row = Math.floor(idx / cols)
                layout.push({
                  image: img,
                  x: col * (tileWidth + gap),
                  y: row * (tileHeight + gap),
                  width: tileWidth,
                  height: tileHeight,
                  delay: idx * 0.01,
                  aspectRatio: getAspectRatio(img)
                })
              })

              if (layout.length > 0) {
                result.push({ layout })
              }
              imageIndex += imagesPerWall
            }
          } else {
            // Adaptive justified layout
            // In imageCount mode, limit images per wall
            const maxImagesPerWall = mosaicControlMode === 'imageCount' ? mosaicImageCount : Infinity

            while (imageIndex < images.length) {
              const layout = []
              let rowY = 0
              let tileIndex = 0
              let wallImageCount = 0

              // Fill the wall with rows
              while (rowY + targetRowHeight * 0.5 <= wallHeight && imageIndex < images.length && wallImageCount < maxImagesPerWall) {
                // Collect images for this row
                const rowImages = []
                let rowAspectSum = 0
                const remainingForWall = maxImagesPerWall - wallImageCount

                // Add images until the row is full
                while (imageIndex < images.length && rowImages.length < 8 && rowImages.length < remainingForWall) {
                  const img = images[imageIndex]
                  const aspectRatio = getAspectRatio(img)

                  // Check if adding this image would make the row too wide
                  const newAspectSum = rowAspectSum + aspectRatio
                  const potentialRowHeight = (wallWidth - rowImages.length * gap) / newAspectSum

                  // If we have at least one image and adding more would make row too short
                  if (rowImages.length > 0 && potentialRowHeight < targetRowHeight * 0.5) {
                    break
                  }

                  rowImages.push({ img, aspectRatio })
                  rowAspectSum = newAspectSum
                  imageIndex++

                  // If row height is good, stop adding
                  if (potentialRowHeight <= targetRowHeight) {
                    break
                  }
                }

                if (rowImages.length === 0) break

                // Calculate row height to fit all images
                let rowHeight = (wallWidth - (rowImages.length - 1) * gap) / rowAspectSum

                // Clamp row height
                rowHeight = Math.min(rowHeight, targetRowHeight * 1.5)
                rowHeight = Math.min(rowHeight, wallHeight - rowY)

                if (rowHeight < 50) break // Too small, stop

                // Check if row fits
                if (rowY + rowHeight > wallHeight) {
                  // Put images back for next wall
                  imageIndex -= rowImages.length
                  break
                }

                // Layout images in this row
                let x = 0
                rowImages.forEach(({ img, aspectRatio }) => {
                  const tileWidth = rowHeight * aspectRatio
                  layout.push({
                    image: img,
                    x,
                    y: rowY,
                    width: Math.min(tileWidth, wallWidth - x),
                    height: rowHeight,
                    delay: tileIndex * 0.02,
                    aspectRatio
                  })
                  x += tileWidth + gap
                  tileIndex++
                  wallImageCount++
                })

                rowY += rowHeight + gap
              }

              if (layout.length > 0) {
                result.push({ layout })
              } else if (imageIndex < images.length) {
                // Fallback: if algorithm fails, just put one image per wall
                const img = images[imageIndex]
                const aspectRatio = getAspectRatio(img)
                const height = Math.min(wallHeight, wallWidth / aspectRatio)
                const width = height * aspectRatio
                result.push({
                  layout: [{
                    image: img,
                    x: (wallWidth - width) / 2,
                    y: (wallHeight - height) / 2,
                    width,
                    height,
                    delay: 0,
                    aspectRatio
                  }]
                })
                imageIndex++
              } else {
                break
              }
            }
          }

          return result
        }, [images, containerSize, mosaicTileSize, mosaicImageCount, mosaicControlMode, imageDimensions, drawerOpen, layoutMode])

        const totalWalls = walls.length

        // Calculate estimated total walls based on average images per wall so far
        const estimatedTotalWalls = useMemo(() => {
          if (walls.length === 0) return Math.max(1, Math.ceil(images.length / 12)) // Rough estimate: ~12 images per wall

          // Count total images in calculated walls
          const imagesInWalls = walls.reduce((sum, wall) => sum + wall.layout.length, 0)
          const avgImagesPerWall = imagesInWalls / walls.length

          // If we've calculated all images, return exact count
          if (imagesInWalls >= images.length) return walls.length

          // Estimate remaining walls
          const remainingImages = images.length - imagesInWalls
          const estimatedRemainingWalls = Math.ceil(remainingImages / avgImagesPerWall)
          return walls.length + estimatedRemainingWalls
        }, [walls, images.length])

        // Check if we have all dimensions loaded (for showing estimate indicator)
        const allDimensionsLoaded = Object.keys(imageDimensions).length >= images.length
        const isEstimate = !allDimensionsLoaded || walls.reduce((sum, w) => sum + w.layout.length, 0) < images.length

        // Ensure currentWall and displayedWall are valid
        useEffect(() => {
          if (totalWalls > 0) {
            if (currentWall >= totalWalls) {
              setCurrentWall(totalWalls - 1)
              setDisplayedWall(totalWalls - 1)
            } else if (displayedWall >= totalWalls) {
              setDisplayedWall(Math.min(currentWall, totalWalls - 1))
            }
          }
        }, [totalWalls, currentWall, displayedWall, setCurrentWall])

        const safeCurrentWall = totalWalls > 0 ? Math.min(currentWall, totalWalls - 1) : 0
        const safeDisplayedWall = totalWalls > 0 ? Math.min(displayedWall, totalWalls - 1) : 0
        const currentWallData = walls[safeDisplayedWall] || { layout: [] }
        const nextWallData = nextWall !== null ? (walls[nextWall] || { layout: [] }) : null

        // Smooth navigation with crossfade animation
        const navigateToWall = useCallback((targetWall) => {
          if (targetWall < 0 || targetWall >= totalWalls || targetWall === displayedWall || isTransitioning) return

          if (enableAnimation) {
            setNextWall(targetWall)
            setIsTransitioning(true)
            setTransitionPhase('out')

            // Phase 1: Fade out current wall
            setTimeout(() => {
              setTransitionPhase('in')
              setDisplayedWall(targetWall)
              setCurrentWall(targetWall)

              // Phase 2: Fade in new wall
              setTimeout(() => {
                setIsTransitioning(false)
                setTransitionPhase(null)
                setNextWall(null)
              }, mosaicAnimationDuration * 0.6)
            }, mosaicAnimationDuration * 0.4)
          } else {
            setDisplayedWall(targetWall)
            setCurrentWall(targetWall)
          }
        }, [displayedWall, totalWalls, enableAnimation, mosaicAnimationDuration, isTransitioning, setCurrentWall])

        const goToNextWall = useCallback(() => {
          if (isTransitioning) return
          if (safeCurrentWall < totalWalls - 1) {
            navigateToWall(safeCurrentWall + 1)
          } else if (mosaicLoopWalls && totalWalls > 1) {
            navigateToWall(0)
          }
        }, [safeCurrentWall, totalWalls, isTransitioning, navigateToWall, mosaicLoopWalls])

        const goToPrevWall = useCallback(() => {
          if (isTransitioning) return
          if (safeCurrentWall > 0) {
            navigateToWall(safeCurrentWall - 1)
          } else if (mosaicLoopWalls && totalWalls > 1) {
            navigateToWall(totalWalls - 1)
          }
        }, [safeCurrentWall, totalWalls, isTransitioning, navigateToWall, mosaicLoopWalls])

        const handleClose = useCallback(() => {
          if (enableAnimation) {
            setIsExiting(true)
            setTimeout(onClose, mosaicAnimationDuration * 0.5)
          } else {
            onClose()
          }
        }, [onClose, enableAnimation, mosaicAnimationDuration])

        // Keyboard navigation
        useEffect(() => {
          const handleKeyDown = (e) => {
            // Don't handle keys when image viewer is open
            if (selectedImage) return

            if (e.key === 'Escape' || e.key === keybindings.toggleMosaicMode) {
              handleClose()
            } else if (e.key === keybindings.mosaicNextWall || e.key === 'ArrowRight') {
              goToNextWall()
            } else if (e.key === keybindings.mosaicPrevWall || e.key === 'ArrowLeft') {
              goToPrevWall()
            } else if (e.key === 'ArrowUp') {
              // More images (smaller tiles) - up means more
              if (mosaicControlMode === 'imageCount') {
                setMosaicImageCount(v => Math.min(100, v + 1))
              } else {
                setMosaicTileSize(v => Math.max(100, v - 20))
              }
            } else if (e.key === 'ArrowDown') {
              // Fewer images (larger tiles) - down means fewer
              if (mosaicControlMode === 'imageCount') {
                setMosaicImageCount(v => Math.max(4, v - 1))
              } else {
                setMosaicTileSize(v => Math.min(400, v + 20))
              }
            } else if (e.key === keybindings.mosaicToggleDrawer) {
              setDrawerOpen(v => !v)
            } else if (e.key === keybindings.mosaicResetTileScale && hoveredTile) {
              // Reset scale of hovered tile
              setTileScales(prev => {
                const newScales = { ...prev }
                delete newScales[hoveredTile]
                return newScales
              })
            }
          }
          document.addEventListener('keydown', handleKeyDown)
          return () => document.removeEventListener('keydown', handleKeyDown)
        }, [handleClose, goToNextWall, goToPrevWall, keybindings, hoveredTile, selectedImage, layoutMode, mosaicControlMode, setMosaicImageCount, setMosaicTileSize])

        // Mouse wheel navigation (when not hovering a tile)
        useEffect(() => {
          const handleWheel = (e) => {
            // Don't handle wheel when image viewer is open
            if (selectedImage) return
            // Only handle wheel for page navigation when not hovering a tile
            if (hoveredTile !== null) return

            e.preventDefault()
            if (e.deltaY > 0) {
              goToNextWall()
            } else if (e.deltaY < 0) {
              goToPrevWall()
            }
          }

          const container = containerRef.current
          if (container) {
            container.addEventListener('wheel', handleWheel, { passive: false })
            return () => container.removeEventListener('wheel', handleWheel)
          }
        }, [goToNextWall, goToPrevWall, hoveredTile, selectedImage])

        // Handle tile scaling with mouse wheel
        const handleTileWheel = useCallback((e, tileKey) => {
          e.preventDefault()
          e.stopPropagation()

          const delta = e.deltaY > 0 ? -0.1 : 0.1
          setTileScales(prev => {
            const currentScale = prev[tileKey] || 1
            const newScale = Math.max(0.5, Math.min(3, currentScale + delta))
            return { ...prev, [tileKey]: newScale }
          })
        }, [])

        // Reset tile scale on double click
        const handleTileDoubleClick = useCallback((e, tileKey) => {
          e.stopPropagation()
          setTileScales(prev => {
            const newScales = { ...prev }
            delete newScales[tileKey]
            return newScales
          })
        }, [])

        // Reset tile scale on middle click
        const handleTileMiddleClick = useCallback((e, tileKey) => {
          if (e.button === 1) { // Middle mouse button
            e.preventDefault()
            e.stopPropagation()
            setTileScales(prev => {
              const newScales = { ...prev }
              delete newScales[tileKey]
              return newScales
            })
          }
        }, [])

        // Render a wall
        const renderWall = (wallData, wallKey, style) => (
          <div
            className="absolute inset-0"
            style={style}
            key={wallKey}
          >
            {wallData.layout.map((tile, idx) => {
              const tileKey = tile.image.fullPath
              const scale = tileScales[tileKey] || 1
              const isHovered = hoveredTile === tileKey

              return (
                <div
                  key={tileKey}
                  className="absolute overflow-visible cursor-pointer transition-all duration-200"
                  style={{
                    left: tile.x,
                    top: tile.y,
                    width: tile.width,
                    height: tile.height,
                    zIndex: isHovered ? 50 : scale > 1 ? 10 : 1
                  }}
                  onMouseEnter={() => setHoveredTile(tileKey)}
                  onMouseLeave={() => setHoveredTile(null)}
                  onWheel={(e) => handleTileWheel(e, tileKey)}
                  onDoubleClick={(e) => handleTileDoubleClick(e, tileKey)}
                  onMouseDown={(e) => handleTileMiddleClick(e, tileKey)}
                  onClick={() => onImageClick(tile.image)}
                >
                  <div
                    className={`w-full h-full rounded-lg overflow-hidden transition-all duration-200 ${isHovered ? 'ring-2 ring-white/70 shadow-2xl' : ''}`}
                    style={{
                      transform: `scale(${scale})`,
                      transformOrigin: 'center center'
                    }}
                  >
                    <img
                      src={tile.image.url}
                      alt={tile.image.name}
                      className="w-full h-full object-cover"
                      loading="lazy"
                      draggable={false}
                    />
                    <div className={`absolute inset-0 bg-gradient-to-t from-black/60 to-transparent transition-opacity duration-200 ${isHovered ? 'opacity-100' : 'opacity-0'}`}>
                      <div className="absolute bottom-2 left-2 right-2 text-white text-sm truncate font-medium">
                        {tile.image.name}
                      </div>
                      {scale !== 1 && (
                        <div className="absolute top-2 right-2 bg-black/60 text-white text-xs px-2 py-1 rounded">
                          {Math.round(scale * 100)}%
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              )
            })}
          </div>
        )

        // Calculate styles based on animation type
        const getWallStyle = (isOutgoing) => {
          if (!enableAnimation) return { opacity: 1 }

          const duration = mosaicAnimationDuration

          if (mosaicAnimationType === 'fade') {
            // Crossfade: both walls visible, opacity changes
            if (isOutgoing) {
              return {
                opacity: transitionPhase === 'out' ? 0 : 1,
                transition: `opacity ${duration * 0.4}ms cubic-bezier(0.4, 0, 0.2, 1)`
              }
            } else {
              return {
                opacity: transitionPhase === 'in' ? 1 : 0,
                transition: `opacity ${duration * 0.6}ms cubic-bezier(0.4, 0, 0.2, 1)`
              }
            }
          } else {
            // Slide: walls slide in opposite directions
            if (isOutgoing) {
              const direction = nextWall > displayedWall ? -1 : 1
              return {
                opacity: transitionPhase === 'out' ? 0 : 1,
                transform: transitionPhase === 'out' ? `translateX(${direction * 30}%) scale(0.95)` : 'translateX(0) scale(1)',
                transition: `all ${duration * 0.4}ms cubic-bezier(0.4, 0, 0.2, 1)`
              }
            } else {
              const direction = nextWall > displayedWall ? 1 : -1
              return {
                opacity: transitionPhase === 'in' ? 1 : 0,
                transform: transitionPhase === 'in' ? 'translateX(0) scale(1)' : `translateX(${direction * 30}%) scale(0.95)`,
                transition: `all ${duration * 0.6}ms cubic-bezier(0.4, 0, 0.2, 1)`
              }
            }
          }
        }

        if (images.length === 0) {
          return (
            <div className={`fixed inset-0 z-40 bg-black flex items-center justify-center transition-opacity duration-200`}>
              <div className="text-white text-xl">{t('mosaic.noImages')}</div>
            </div>
          )
        }

        const containerStyle = {
          opacity: isEntering ? 0 : isExiting ? 0 : 1,
          transform: isEntering ? 'scale(0.98)' : isExiting ? 'scale(0.98)' : 'scale(1)',
          transition: `all ${mosaicAnimationDuration * 0.5}ms cubic-bezier(0.4, 0, 0.2, 1)`
        }

        const drawerHeight = drawerOpen ? 140 : 0

        // Debug: if walls is empty but we have images, show debug info
        if (walls.length === 0 && images.length > 0) {
          return (
            <div
              ref={containerRef}
              className={`fixed inset-0 z-40 bg-black flex flex-col items-center justify-center text-white transition-opacity duration-200`}
            >
              <div className="text-xl mb-4">Building gallery...</div>
              <div className="text-sm text-white/60 space-y-1">
                <div>Images: {images.length}</div>
                <div>Container: {containerSize.width} x {containerSize.height}</div>
                <div>Dimensions loaded: {Object.keys(imageDimensions).length}</div>
                <div>Tile size: {mosaicTileSize}</div>
              </div>
            </div>
          )
        }

        return (
          <div
            ref={containerRef}
            className={`fixed inset-0 z-40 bg-black transition-opacity duration-200`}
            style={enableAnimation && !selectedImage ? containerStyle : {}}
          >
            {/* Wall display */}
            <div
              className="relative w-full p-4 transition-all duration-300"
              style={{ height: drawerOpen ? `calc(100% - 140px)` : '100%' }}
            >
              <div className="relative w-full h-full overflow-hidden">
                {/* Current wall */}
                {renderWall(
                  currentWallData,
                  `wall-${safeDisplayedWall}`,
                  isTransitioning ? getWallStyle(true) : { opacity: 1 }
                )}
              </div>
            </div>

            {/* Drawer toggle button - only visible when drawer is open */}
            {drawerOpen && (
              <button
                onClick={() => setDrawerOpen(false)}
                className="absolute left-1/2 -translate-x-1/2 bottom-[143px] bg-white/20 hover:bg-white/30 text-white px-4 py-1 rounded-full text-xs transition-all flex items-center gap-1 z-10"
              >
                ‚ñº {t('mosaic.hideControls')} ({formatKey(keybindings.mosaicToggleDrawer)})
              </button>
            )}

            {/* Collapsible Controls Drawer */}
            <div
              className={`absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black via-black/90 to-black/70 transition-all duration-300 overflow-hidden ${
                drawerOpen ? 'opacity-100' : 'opacity-0 pointer-events-none'
              }`}
              style={{ height: drawerOpen ? 140 : 0 }}
            >
              <div className="p-4 pt-4">
                {/* Layout mode toggle and Tile size slider */}
                <div className="flex items-center justify-center gap-6 mb-3">
                  {/* Layout mode toggle */}
                  <div className="flex items-center gap-2">
                    <button
                      onClick={() => setLayoutMode(layoutMode === 'fixed' ? 'adaptive' : 'fixed')}
                      className={`px-3 py-1 rounded-lg text-xs transition-all ${
                        layoutMode === 'fixed'
                          ? 'bg-white/30 text-white'
                          : 'bg-white/10 text-white/60 hover:bg-white/20'
                      }`}
                    >
                      {t('mosaic.fixedGrid')}
                    </button>
                    <button
                      onClick={() => setLayoutMode(layoutMode === 'adaptive' ? 'fixed' : 'adaptive')}
                      className={`px-3 py-1 rounded-lg text-xs transition-all ${
                        layoutMode === 'adaptive'
                          ? 'bg-white/30 text-white'
                          : 'bg-white/10 text-white/60 hover:bg-white/20'
                      }`}
                    >
                      {t('mosaic.adaptiveGrid')}
                    </button>
                  </div>

                  {/* Size control - shows tile size or image count based on control mode */}
                  <div className="flex items-center gap-2">
                    {mosaicControlMode === 'imageCount' ? (
                      <>
                        <span className="text-white/60 text-xs">{t('mosaic.imagesPerWall')}</span>
                        <input
                          type="range"
                          min="4"
                          max="100"
                          step="1"
                          value={mosaicImageCount}
                          onChange={(e) => setMosaicImageCount(parseInt(e.target.value))}
                          className="w-24 h-1 bg-white/30 rounded-lg appearance-none cursor-pointer"
                        />
                        <span className="text-white/60 text-xs w-8">{mosaicImageCount}</span>
                      </>
                    ) : (
                      <>
                        <span className="text-white/60 text-xs">{t('mosaic.tileSize')}</span>
                        <input
                          type="range"
                          min="100"
                          max="400"
                          step="20"
                          value={mosaicTileSize}
                          onChange={(e) => setMosaicTileSize(parseInt(e.target.value))}
                          className="w-24 h-1 bg-white/30 rounded-lg appearance-none cursor-pointer"
                        />
                        <span className="text-white/60 text-xs w-12">{mosaicTileSize}px</span>
                      </>
                    )}
                  </div>
                </div>

                <div className="flex items-center justify-between max-w-4xl mx-auto">
                  {/* Previous button */}
                  <button
                    onClick={goToPrevWall}
                    disabled={(safeCurrentWall === 0 && !mosaicLoopWalls) || isTransitioning}
                    className="bg-white/20 hover:bg-white/30 disabled:opacity-30 disabled:cursor-not-allowed text-white px-4 py-2 rounded-lg transition-all flex items-center gap-2"
                  >
                    ‚Üê {t('navigation.back')}
                  </button>

                  {/* Wall indicator */}
                  <div className="flex items-center gap-4">
                    <div className="flex flex-col items-center">
                      <span className="text-white/80 text-sm">
                        {t('mosaic.wall')} {safeCurrentWall + 1} {t('mosaic.of')} {isEstimate ? '~' : ''}{isEstimate ? estimatedTotalWalls : totalWalls}
                      </span>
                      {isEstimate && (
                        <span className="text-white/40 text-xs">
                          ({Object.keys(imageDimensions).length}/{images.length} loaded)
                        </span>
                      )}
                    </div>
                    <div className="flex gap-1">
                      {walls.slice(0, 20).map((_, idx) => (
                        <button
                          key={idx}
                          onClick={() => navigateToWall(idx)}
                          disabled={isTransitioning}
                          className={`w-2 h-2 rounded-full transition-all ${
                            idx === safeCurrentWall ? 'bg-white w-4' : 'bg-white/40 hover:bg-white/60'
                          }`}
                        />
                      ))}
                      {(walls.length > 20 || isEstimate) && (
                        <span className="text-white/40 text-xs ml-1">
                          {walls.length > 20 ? `+${isEstimate ? '~' : ''}${(isEstimate ? estimatedTotalWalls : totalWalls) - 20}` : (isEstimate ? '~' : '')}
                        </span>
                      )}
                    </div>
                  </div>

                  {/* Next button */}
                  <button
                    onClick={goToNextWall}
                    disabled={(safeCurrentWall >= totalWalls - 1 && !mosaicLoopWalls) || isTransitioning}
                    className="bg-white/20 hover:bg-white/30 disabled:opacity-30 disabled:cursor-not-allowed text-white px-4 py-2 rounded-lg transition-all flex items-center gap-2"
                  >
                    {t('navigation.forward')} ‚Üí
                  </button>
                </div>

                {/* Exit hint */}
                <div className="text-center mt-2 text-white/50 text-xs">
                  {t('mosaic.exitHint', { key: formatKey(keybindings.toggleMosaicMode) })} ‚Ä¢ {formatKey(keybindings.mosaicToggleDrawer)}: {t('mosaic.toggleDrawer')} ‚Ä¢ {t('mosaic.wheelHint')}
                </div>
              </div>
            </div>
          </div>
        )
      })

      const createNewTab = (id = Date.now()) => ({
        id,
        selectedDir: '',
        allImages: [],
        displayedImages: [],
        searchTerm: '',
        dirHistory: [],
        historyIndex: -1
      })

      const ImageViewerApp = () => {
        const { t } = useI18n()
        const [tabs, setTabs] = useState(() => {
          const saved = localStorage.getItem('tabs')
          if (saved) {
            try {
              const parsed = JSON.parse(saved)
              if (Array.isArray(parsed) && parsed.length > 0) {
                return parsed.map(t => ({ ...createNewTab(), ...t, allImages: [], displayedImages: [] }))
              }
            } catch (e) {}
          }
          return [createNewTab(1)]
        })
        const [activeTabId, setActiveTabId] = useState(() => {
          const saved = localStorage.getItem('activeTabId')
          return saved ? parseInt(saved) : 1
        })

        const activeTab = tabs.find(t => t.id === activeTabId) || tabs[0]
        const activeTabIndex = tabs.findIndex(t => t.id === activeTabId)

        const updateActiveTab = useCallback((updates) => {
          setTabs(prev => prev.map(t => t.id === activeTabId ? { ...t, ...updates } : t))
        }, [activeTabId])

        const [loading, setLoading] = useState(false)
        const [loadingMore, setLoadingMore] = useState(false)
        const [selectedImage, setSelectedImage] = useState(null)
        const [deleteMode, setDeleteMode] = useState(false)
        const [theme, setTheme] = useState(
          () => localStorage.getItem('theme') || 'midnight'
        )
        const currentTheme = THEMES[theme] || THEMES.midnight
        const [sortBy, setSortBy] = useState(
          () => localStorage.getItem('sortBy') || 'name'
        )
        const [sortOrder, setSortOrder] = useState(
          () => localStorage.getItem('sortOrder') || 'asc'
        )
        const [columnCount, setColumnCount] = useState(
          () => parseInt(localStorage.getItem('columnCount')) || 4
        )
        const [selectedForDeletion, setSelectedForDeletion] = useState(
          new Set()
        )
        const [favoritesDir, setFavoritesDir] = useState('')
        const [isDragOver, setIsDragOver] = useState(false)
        const [showHelp, setShowHelp] = useState(false)
        const [showStarButton, setShowStarButton] = useState(
          () => localStorage.getItem('showStarButton') !== 'false'
        )
        const [keybindings, setKeybindings] = useState(() => {
          const saved = localStorage.getItem('keybindings')
          return saved ? { ...DEFAULT_KEYBINDINGS, ...JSON.parse(saved) } : DEFAULT_KEYBINDINGS
        })
        const [showSettings, setShowSettings] = useState(false)
        const [editingKey, setEditingKey] = useState(null)
        const [clickOutsideToClose, setClickOutsideToClose] = useState(
          () => localStorage.getItem('clickOutsideToClose') !== 'false'
        )
        const [confirmPrompts, setConfirmPrompts] = useState(
          () => localStorage.getItem('confirmPrompts') === 'true'
        )
        const [showActionFeedback, setShowActionFeedback] = useState(
          () => localStorage.getItem('showActionFeedback') === 'true'
        )
        const [maxImageSize, setMaxImageSize] = useState(
          () => parseInt(localStorage.getItem('maxImageSize')) || 90
        )
        const [showHistoryPanel, setShowHistoryPanel] = useState(false)
        const [mainContextMenu, setMainContextMenu] = useState(null)
        const [starVersion, setStarVersion] = useState(0)
        const [recentDirs, setRecentDirs] = useState(() => {
          const saved = localStorage.getItem('recentDirs')
          return saved ? JSON.parse(saved) : []
        })
        const [retainImages, setRetainImages] = useState(
          () => localStorage.getItem('retainImages') === 'true'
        )
        const [showMosaicMode, setShowMosaicMode] = useState(false)
        const [mosaicAnimation, setMosaicAnimation] = useState(
          () => localStorage.getItem('mosaicAnimation') !== 'false'
        )
        const [mosaicAnimationType, setMosaicAnimationType] = useState(
          () => localStorage.getItem('mosaicAnimationType') || 'fade'
        )
        const [mosaicAnimationDuration, setMosaicAnimationDuration] = useState(
          () => parseInt(localStorage.getItem('mosaicAnimationDuration')) || 300
        )
        const [mosaicTileSize, setMosaicTileSize] = useState(
          () => parseInt(localStorage.getItem('mosaicTileSize')) || 200
        )
        const [mosaicImageCount, setMosaicImageCount] = useState(() => {
          const stored = localStorage.getItem('mosaicImageCount')
          return stored ? parseInt(stored) : 20
        })
        const [mosaicControlMode, setMosaicControlMode] = useState(() => {
          return localStorage.getItem('mosaicControlMode') || 'imageCount'
        })
        const [mosaicCurrentWall, setMosaicCurrentWall] = useState(0)
        const [mosaicLoopWalls, setMosaicLoopWalls] = useState(
          () => localStorage.getItem('mosaicLoopWalls') !== 'false'
        )

        // Save mosaic settings to localStorage
        useEffect(() => {
          localStorage.setItem('mosaicImageCount', mosaicImageCount.toString())
        }, [mosaicImageCount])
        useEffect(() => {
          localStorage.setItem('mosaicControlMode', mosaicControlMode)
        }, [mosaicControlMode])

        // Derived values from active tab
        const selectedDir = activeTab.selectedDir
        const allImages = activeTab.allImages
        const displayedImages = activeTab.displayedImages
        const searchTerm = activeTab.searchTerm
        const dirHistory = activeTab.dirHistory
        const historyIndex = activeTab.historyIndex

        const scrollContainerRef = useRef(null)
        const loadMoreObserverRef = useRef(null)

        const filteredImages = useMemo(() => {
          let imgs = allImages
          if (searchTerm) {
            imgs = imgs.filter(
              img =>
                img.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                img.path.toLowerCase().includes(searchTerm.toLowerCase()) ||
                img.directory.toLowerCase().includes(searchTerm.toLowerCase())
            )
          }
          const sorted = [...imgs].sort((a, b) => {
            let cmp = 0
            if (sortBy === 'name') cmp = a.name.localeCompare(b.name)
            else if (sortBy === 'date') cmp = b.lastModified - a.lastModified
            else if (sortBy === 'size') cmp = b.size - a.size
            return sortOrder === 'asc' ? cmp : -cmp
          })
          return sorted
        }, [allImages, searchTerm, sortBy, sortOrder])

        const loadedCount = displayedImages.length
        const hasMore = loadedCount < filteredImages.length

        useEffect(() => {
          localStorage.setItem('theme', theme)
        }, [theme])

        useEffect(() => {
          localStorage.setItem('sortBy', sortBy)
        }, [sortBy])

        useEffect(() => {
          localStorage.setItem('sortOrder', sortOrder)
        }, [sortOrder])

        useEffect(() => {
          localStorage.setItem('columnCount', columnCount.toString())
        }, [columnCount])

        useEffect(() => {
          localStorage.setItem('showStarButton', showStarButton.toString())
        }, [showStarButton])

        useEffect(() => {
          localStorage.setItem('keybindings', JSON.stringify(keybindings))
        }, [keybindings])

        useEffect(() => {
          localStorage.setItem('clickOutsideToClose', clickOutsideToClose.toString())
        }, [clickOutsideToClose])

        useEffect(() => {
          localStorage.setItem('confirmPrompts', confirmPrompts.toString())
        }, [confirmPrompts])

        useEffect(() => {
          localStorage.setItem('showActionFeedback', showActionFeedback.toString())
        }, [showActionFeedback])

        useEffect(() => {
          localStorage.setItem('maxImageSize', maxImageSize.toString())
        }, [maxImageSize])

        useEffect(() => {
          localStorage.setItem('recentDirs', JSON.stringify(recentDirs))
        }, [recentDirs])

        useEffect(() => {
          localStorage.setItem('retainImages', retainImages.toString())
        }, [retainImages])

        useEffect(() => {
          localStorage.setItem('mosaicAnimation', mosaicAnimation.toString())
        }, [mosaicAnimation])

        useEffect(() => {
          localStorage.setItem('mosaicAnimationType', mosaicAnimationType)
        }, [mosaicAnimationType])

        useEffect(() => {
          localStorage.setItem('mosaicAnimationDuration', mosaicAnimationDuration.toString())
        }, [mosaicAnimationDuration])

        useEffect(() => {
          localStorage.setItem('mosaicTileSize', mosaicTileSize.toString())
        }, [mosaicTileSize])

        useEffect(() => {
          localStorage.setItem('mosaicLoopWalls', mosaicLoopWalls.toString())
        }, [mosaicLoopWalls])

        useEffect(() => {
          // Save tabs (without images to avoid huge localStorage)
          const tabsToSave = tabs.map(t => ({
            id: t.id,
            selectedDir: t.selectedDir,
            searchTerm: t.searchTerm,
            dirHistory: t.dirHistory,
            historyIndex: t.historyIndex
          }))
          localStorage.setItem('tabs', JSON.stringify(tabsToSave))
        }, [tabs])

        useEffect(() => {
          localStorage.setItem('activeTabId', activeTabId.toString())
        }, [activeTabId])

        useEffect(() => {
          const fetchFavoritesDir = async () => {
            const dir = await window.electronAPI.getFavoritesDir()
            setFavoritesDir(dir)
          }
          fetchFavoritesDir()
        }, [])

        // Reload images when switching tabs if the tab has a directory but no images
        useEffect(() => {
          if (activeTab.selectedDir && activeTab.allImages.length === 0) {
            loadDir(activeTab.selectedDir, false)
          }
        }, [activeTabId])

        const loadDir = useCallback(async (dirPath, addToHistory = true) => {
          if (!dirPath) return
          try {
            setLoading(true)
            setSelectedForDeletion(new Set())
            setDeleteMode(false)
            setMosaicCurrentWall(0) // Reset mosaic wall position
            const images = await window.electronAPI.getImages(dirPath)
            if (addToHistory) {
              updateActiveTab({
                selectedDir: dirPath,
                allImages: images,
                searchTerm: '',
                dirHistory: [...dirHistory.slice(0, historyIndex + 1), dirPath],
                historyIndex: historyIndex + 1
              })
              // Add to persistent recent dirs (keep last 20, no duplicates)
              setRecentDirs(prev => {
                const filtered = prev.filter(d => d !== dirPath)
                return [dirPath, ...filtered].slice(0, 20)
              })
            } else {
              updateActiveTab({
                selectedDir: dirPath,
                allImages: images,
                searchTerm: ''
              })
            }
          } catch (error) {
            console.error('Error loading directory:', error)
            alert(t('prompts.errorLoading') + ': ' + error.message)
          } finally {
            setLoading(false)
          }
        }, [historyIndex, dirHistory, updateActiveTab])

        const handleDirSelect = useCallback(async () => {
          const dirPath = await window.electronAPI.selectDirectory()
          if (dirPath) loadDir(dirPath)
        }, [loadDir])

        const goBack = useCallback(() => {
          if (historyIndex > 0) {
            const newIndex = historyIndex - 1
            updateActiveTab({ historyIndex: newIndex })
            loadDir(dirHistory[newIndex], false)
          }
        }, [historyIndex, dirHistory, loadDir, updateActiveTab])

        const goForward = useCallback(() => {
          if (historyIndex < dirHistory.length - 1) {
            const newIndex = historyIndex + 1
            updateActiveTab({ historyIndex: newIndex })
            loadDir(dirHistory[newIndex], false)
          }
        }, [historyIndex, dirHistory, loadDir, updateActiveTab])

        useEffect(() => {
          const handleMouseButton = e => {
            if (selectedImage) return
            if (e.button === 3) { e.preventDefault(); goBack() }
            else if (e.button === 4) { e.preventDefault(); goForward() }
          }
          window.addEventListener('mouseup', handleMouseButton)
          return () => window.removeEventListener('mouseup', handleMouseButton)
        }, [goBack, goForward, selectedImage])

        // Global keyboard shortcuts for main window
        useEffect(() => {
          const handleGlobalKeyPress = e => {
            // Don't trigger if modal is open or typing in input
            if (selectedImage || e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return

            const key = e.key
            if ((e.ctrlKey || e.metaKey) && key === keybindings.openDirectory) { e.preventDefault(); handleDirSelect() }
            else if ((e.ctrlKey || e.metaKey) && key === keybindings.newTab) {
              e.preventDefault()
              const newTab = createNewTab()
              setTabs(prev => [...prev, newTab])
              setActiveTabId(newTab.id)
            }
            else if ((e.ctrlKey || e.metaKey) && key === keybindings.closeTab) {
              e.preventDefault()
              if (tabs.length > 1) {
                const newTabs = tabs.filter(t => t.id !== activeTabId)
                setTabs(newTabs)
                setActiveTabId(newTabs[0].id)
              }
            }
            else if (key === keybindings.viewFavorites || key === 'F') { viewFavorites() }
            else if (key === keybindings.toggleDeleteMode) { setDeleteMode(d => !d) }
            else if (key === keybindings.toggleDarkMode || key === 'M') { setDarkMode(d => !d) }
            else if (key === keybindings.openSettings) { setShowSettings(true) }
            else if (key === keybindings.openHelp) { setShowHelp(true) }
            else if (key === keybindings.toggleHistoryPanel || key === 'H') { setShowHistoryPanel(v => !v) }
            else if (key === keybindings.toggleMosaicMode || key === 'G') { if (filteredImages.length > 0) setShowMosaicMode(v => !v) }
          }
          document.addEventListener('keydown', handleGlobalKeyPress)
          return () => document.removeEventListener('keydown', handleGlobalKeyPress)
        }, [selectedImage, keybindings, handleDirSelect, viewFavorites, tabs, activeTabId])

        useEffect(() => {
          setTabs(prev => prev.map(t => t.id === activeTabId ? { ...t, displayedImages: filteredImages.slice(0, BATCH_SIZE) } : t))
          if (scrollContainerRef.current) {
            scrollContainerRef.current.scrollTop = 0
          }
        }, [filteredImages, activeTabId])

        const loadMoreImages = useCallback(() => {
          if (loadingMore || !hasMore) return
          setLoadingMore(true)
          setTimeout(() => {
            const nextBatch = filteredImages.slice(
              loadedCount,
              loadedCount + BATCH_SIZE
            )
            setTabs(prev => prev.map(t => t.id === activeTabId ? { ...t, displayedImages: [...t.displayedImages, ...nextBatch] } : t))
            setLoadingMore(false)
          }, 300)
        }, [filteredImages, loadedCount, loadingMore, hasMore, activeTabId])

        useEffect(() => {
          const scrollContainer = scrollContainerRef.current
          if (!scrollContainer || !hasMore) return

          // IntersectionObserver for infinite scroll
          const observer = new IntersectionObserver(
            entries => {
              const [entry] = entries
              if (entry.isIntersecting && !loadingMore) {
                loadMoreImages()
              }
            },
            { root: scrollContainer, rootMargin: '600px', threshold: 0.1 }
          )

          const observerTarget = loadMoreObserverRef.current
          if (observerTarget) {
            observer.observe(observerTarget)
          }

          // Fallback scroll handler for cases where IntersectionObserver doesn't trigger
          const handleScroll = () => {
            if (loadingMore || !hasMore) return
            const { scrollTop, scrollHeight, clientHeight } = scrollContainer
            if (scrollTop + clientHeight >= scrollHeight - 800) {
              loadMoreImages()
            }
          }

          scrollContainer.addEventListener('scroll', handleScroll, { passive: true })

          return () => {
            if (observerTarget) {
              observer.unobserve(observerTarget)
            }
            scrollContainer.removeEventListener('scroll', handleScroll)
          }
        }, [loadMoreImages, hasMore, loadingMore, selectedDir, displayedImages.length])

        const handleBatchDelete = useCallback(
          async pathsToDelete => {
            const numToDelete = pathsToDelete.length
            if (numToDelete === 0) return
            if (confirmPrompts) {
              const confirmMessage = t('deleteMode.confirmDelete', { count: numToDelete })
              if (!confirm(confirmMessage)) return
            }

            try {
              await window.electronAPI.deleteImage(pathsToDelete)
              const deletedPathsSet = new Set(pathsToDelete)

              updateActiveTab({
                allImages: allImages.filter(img => !deletedPathsSet.has(img.fullPath)),
                displayedImages: displayedImages.filter(img => !deletedPathsSet.has(img.fullPath))
              })

              if (selectedForDeletion.size > 0)
                setSelectedForDeletion(new Set())
              if (selectedImage && deletedPathsSet.has(selectedImage.fullPath))
                setSelectedImage(null)
            } catch (error) {
              console.error('Error deleting image(s):', error)
              alert(t('prompts.errorDeleting') + ': ' + error.message)
            }
          },
          [selectedImage, selectedForDeletion, confirmPrompts, allImages, displayedImages, updateActiveTab, t]
        )

        const handleStarImage = useCallback(async image => {
          try {
            const result = await window.electronAPI.starImage(image.fullPath)
            if (result.exists) {
              if (!confirmPrompts || confirm(t('star.alreadyStarred'))) {
                await window.electronAPI.unstarImage(result.starredPath)
              }
            }
            setStarVersion(v => v + 1)
          } catch (error) {
            console.error('Failed to star image:', error)
            alert(t('prompts.error') + ': ' + error.message)
          }
        }, [confirmPrompts, t])

        const viewFavorites = useCallback(async () => {
          if (!favoritesDir || loading) return
          loadDir(favoritesDir)
        }, [favoritesDir, loading, loadDir])

        const handleToggleDeleteMode = () => {
          setDeleteMode(prev => {
            if (prev) {
              setSelectedForDeletion(new Set())
            }
            return !prev
          })
        }
        const handleToggleImageSelection = useCallback(image => {
          setSelectedForDeletion(prevSet => {
            const newSet = new Set(prevSet)
            if (newSet.has(image.fullPath)) {
              newSet.delete(image.fullPath)
            } else {
              newSet.add(image.fullPath)
            }
            return newSet
          })
        }, [])
        const isSelectedForDeletion = useCallback(
          image => selectedForDeletion.has(image.fullPath),
          [selectedForDeletion]
        )
        const openFileLocation = useCallback(async image => {
          try {
            await window.electronAPI.openFileLocation(image.fullPath)
          } catch (error) {
            console.error('Error opening file location:', error)
            alert(t('prompts.errorOpeningLocation') + ': ' + error.message)
          }
        }, [t])
        const handleImageClick = useCallback(
          image => setSelectedImage(image),
          []
        )
        const handleModalClose = useCallback(() => setSelectedImage(null), [])

        const handleMainContextMenu = useCallback((e, image) => {
          setMainContextMenu({ x: e.clientX, y: e.clientY, image })
        }, [])

        const closeMainContextMenu = useCallback(() => setMainContextMenu(null), [])

        const handleDrop = useCallback(async e => {
          e.preventDefault()
          setIsDragOver(false)
          const items = e.dataTransfer.items
          for (const item of items) {
            if (item.kind === 'file') {
              const entry = item.webkitGetAsEntry?.()
              if (entry?.isDirectory) {
                const dirPath = e.dataTransfer.files[0]?.path
                if (dirPath) loadDir(dirPath)
                break
              }
            }
          }
        }, [loadDir])

        const handleDragOver = useCallback(e => {
          e.preventDefault()
          setIsDragOver(true)
        }, [])

        const handleDragLeave = useCallback(e => {
          e.preventDefault()
          setIsDragOver(false)
        }, [])

        return (
          <div
            ref={scrollContainerRef}
            className={`app-container transition-colors duration-300 ${currentTheme.bg} ${currentTheme.text} ${isDragOver ? 'ring-4 ring-inset ring-blue-500' : ''}`}
            onDrop={handleDrop}
            onDragOver={handleDragOver}
            onDragLeave={handleDragLeave}
          >
            <header
              className={`sticky top-0 z-40 border-b backdrop-blur-sm transition-colors ${currentTheme.header} ${currentTheme.border}`}
            >
              {/* Tab Bar */}
              <div className={`flex items-center gap-1 px-2 pt-2 border-b ${currentTheme.border}`}>
                {tabs.map(tab => (
                  <div
                    key={tab.id}
                    className={`group flex items-center gap-1 px-3 py-1.5 rounded-t-lg cursor-pointer transition-colors ${
                      tab.id === activeTabId
                        ? `${currentTheme.bg} ${currentTheme.text}`
                        : `${currentTheme.button} ${currentTheme.textSecondary}`
                    }`}
                    onClick={() => setActiveTabId(tab.id)}
                  >
                    <span className="text-sm truncate max-w-[120px]">
                      {tab.selectedDir ? tab.selectedDir.split(/[\\/]/).pop() : t('navigation.newTab')}
                    </span>
                    {tabs.length > 1 && (
                      <button
                        onClick={e => {
                          e.stopPropagation()
                          const newTabs = tabs.filter(t => t.id !== tab.id)
                          setTabs(newTabs)
                          if (tab.id === activeTabId) {
                            setActiveTabId(newTabs[0].id)
                          }
                        }}
                        className="opacity-0 group-hover:opacity-100 ml-1 text-gray-500 hover:text-red-500 transition-opacity"
                      >
                        ‚úï
                      </button>
                    )}
                  </div>
                ))}
                <button
                  onClick={() => {
                    const newTab = createNewTab()
                    setTabs(prev => [...prev, newTab])
                    setActiveTabId(newTab.id)
                  }}
                  className={`p-1.5 rounded-lg transition-colors ${currentTheme.button} ${currentTheme.textSecondary}`}
                  title={t('navigation.newTab')}
                >
                  +
                </button>
              </div>
              <div className="max-w-7xl mx-auto px-4 py-4">
                <div className="flex items-center justify-between gap-4 flex-wrap">
                  <h1 className={`text-2xl font-bold bg-gradient-to-r ${currentTheme.gradient} bg-clip-text text-transparent`}>
                    {t('app.title')}
                  </h1>
                  <div className="flex items-center gap-2 flex-wrap">
                    <button
                      onClick={goBack}
                      disabled={historyIndex <= 0}
                      className={`p-2 rounded-lg transition-all ${currentTheme.button} disabled:opacity-40`}
                      title={t('navigation.back')}
                    >
                      ‚óÄ
                    </button>
                    <button
                      onClick={goForward}
                      disabled={historyIndex >= dirHistory.length - 1}
                      className={`p-2 rounded-lg transition-all ${currentTheme.button} disabled:opacity-40`}
                      title={t('navigation.forward')}
                    >
                      ‚ñ∂
                    </button>
                    <button
                      onClick={() => setShowHistoryPanel(v => !v)}
                      className={`p-2 rounded-lg transition-all ${showHistoryPanel ? currentTheme.accent + ' text-white' : currentTheme.button}`}
                      title={t('navigation.historyAndRecent')}
                    >
                      üìú
                    </button>
                    <button
                      onClick={handleDirSelect}
                      disabled={loading}
                      className={`flex items-center gap-2 px-4 py-2 rounded-lg transition-all font-medium ${currentTheme.accent} text-white disabled:opacity-40`}
                    >
                      üìÅ{' '}
                      {loading
                        ? t('app.scanning')
                        : selectedDir
                        ? window.path.basename(selectedDir)
                        : t('actions.selectDirectory')}
                    </button>
                    <button
                      onClick={viewFavorites}
                      disabled={!favoritesDir || loading}
                      title={t('star.viewStarred')}
                      className="flex items-center gap-2 px-4 py-2 rounded-lg transition-all font-medium bg-amber-500 hover:bg-amber-600 text-white disabled:opacity-40"
                    >
                      ‚≠ê
                    </button>
                    {allImages.length > 0 && (
                      <button
                        onClick={handleToggleDeleteMode}
                        className={`flex items-center gap-2 px-4 py-2 rounded-lg transition-all font-medium ${
                          deleteMode ? 'bg-red-600 hover:bg-red-700 text-white' : currentTheme.button
                        }`}
                      >
                        üóëÔ∏è {deleteMode ? t('actions.cancel') : t('deleteMode.selectToDelete')}
                      </button>
                    )}
                    {allImages.length > 0 && (
                      <button
                        onClick={() => setShowMosaicMode(true)}
                        className={`p-2 rounded-lg transition-all ${currentTheme.button}`}
                        title={t('mosaic.title') + ' (G)'}
                      >
                        üñºÔ∏è
                      </button>
                    )}
                    <button
                      onClick={() => setShowHelp(true)}
                      className={`p-2 rounded-lg transition-all ${currentTheme.button}`}
                      title={t('help.title')}
                    >
                      ‚ùì
                    </button>
                    <button
                      onClick={() => setShowSettings(true)}
                      className={`p-2 rounded-lg transition-all ${currentTheme.button}`}
                      title={t('settings.title')}
                    >
                      ‚öôÔ∏è
                    </button>
                  </div>
                </div>
                {allImages.length > 0 && (
                  <div className="mt-4 flex items-center justify-between gap-4 flex-wrap">
                    <div className="flex-1 max-w-md">
                      <div className="relative">
                        <span className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-500">
                          üîç
                        </span>
                        <input
                          type="text"
                          placeholder={t('images.searchPlaceholder')}
                          value={searchTerm}
                          onChange={e => updateActiveTab({ searchTerm: e.target.value })}
                          className={`w-full pl-10 pr-4 py-2 rounded-lg border transition-colors ${currentTheme.input} focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50`}
                        />
                      </div>
                    </div>
                    <div className="flex items-center gap-2">
                      <div className={`flex items-center rounded-lg border overflow-hidden ${currentTheme.border}`}>
                        <select
                          value={sortBy}
                          onChange={e => setSortBy(e.target.value)}
                          className={`px-3 py-2 border-none transition-colors ${currentTheme.bgSecondary} ${currentTheme.text}`}
                        >
                          <option value="name">{t('sort.name')}</option>
                          <option value="date">{t('sort.date')}</option>
                          <option value="size">{t('sort.size')}</option>
                        </select>
                        <button
                          onClick={() => setSortOrder(o => o === 'asc' ? 'desc' : 'asc')}
                          className={`px-3 py-2 border-l transition-colors ${currentTheme.bgSecondary} ${currentTheme.border} ${currentTheme.text}`}
                          title={sortOrder === 'asc' ? t('sort.ascending') : t('sort.descending')}
                        >
                          {sortBy === 'name'
                            ? (sortOrder === 'asc' ? 'A‚ÜíZ' : 'Z‚ÜíA')
                            : sortBy === 'date'
                            ? (sortOrder === 'asc' ? 'üïê‚Üì' : 'üïê‚Üë')
                            : (sortOrder === 'asc' ? 'L‚ÜíS' : 'S‚ÜíL')}
                        </button>
                      </div>
                      <div className={`flex items-center gap-1 px-2 py-1 rounded-lg border ${currentTheme.border}`}>
                        <button
                          onClick={() => setColumnCount(c => Math.max(2, c - 1))}
                          className={`px-2 py-1 rounded ${currentTheme.button}`}
                          disabled={columnCount <= 2}
                        >-</button>
                        <span className="px-2 text-sm">{columnCount} {t('sort.columns')}</span>
                        <button
                          onClick={() => setColumnCount(c => Math.min(8, c + 1))}
                          className={`px-2 py-1 rounded ${currentTheme.button}`}
                          disabled={columnCount >= 8}
                        >+</button>
                      </div>
                      <button
                        onClick={() => setShowStarButton(s => !s)}
                        className={`px-2 py-2 rounded-lg border transition-colors ${
                          showStarButton ? 'bg-amber-500 border-amber-500 text-white' : `${currentTheme.bgSecondary} ${currentTheme.border} ${currentTheme.textSecondary}`
                        }`}
                        title={showStarButton ? t('star.hideQuickStar') : t('star.showQuickStar')}
                      >
                        ‚≠ê
                      </button>
                    </div>
                    <div className={`text-sm ${currentTheme.textSecondary} whitespace-nowrap`}>{t('images.showingOf', { shown: displayedImages.length, total: filteredImages.length })}</div>
                  </div>
                )}
              </div>
            </header>
            {showHistoryPanel && (
              <div className="fixed inset-0 z-50" onClick={() => setShowHistoryPanel(false)}>
                <div
                  className={`absolute top-20 left-4 right-4 max-w-2xl mx-auto backdrop-blur-xl rounded-xl shadow-2xl border ${currentTheme.bgSecondary} ${currentTheme.border}`}
                  onClick={e => e.stopPropagation()}
                >
                  <div className="p-4">
                    <div className="flex items-center justify-between mb-3">
                      <span className="text-lg font-semibold">{t('navigation.historyAndRecent')}</span>
                      <button
                        onClick={() => setShowHistoryPanel(false)}
                        className={`${currentTheme.textSecondary} hover:opacity-70 p-1`}
                      >
                        ‚úï
                      </button>
                    </div>

                    {dirHistory.length > 0 && (
                      <div className="mb-4">
                        <div className="flex items-center justify-between mb-2">
                          <span className={`text-sm font-medium ${currentTheme.textSecondary}`}>{t('navigation.sessionHistory')} ({dirHistory.length})</span>
                          <button
                            onClick={() => updateActiveTab({ dirHistory: [], historyIndex: -1 })}
                            className={`text-xs px-2 py-0.5 rounded ${currentTheme.button} hover:text-red-400`}
                            title={t('actions.clearAll')}
                          >
                            {t('actions.clearAll')}
                          </button>
                        </div>
                        <div className="flex flex-wrap gap-2 max-h-24 overflow-y-auto">
                          {dirHistory.map((dir, idx) => (
                            <div key={idx} className="group relative">
                              <button
                                onClick={() => {
                                  updateActiveTab({ historyIndex: idx })
                                  loadDir(dir, false)
                                  setShowHistoryPanel(false)
                                }}
                                className={`px-3 py-1 pr-6 rounded text-sm truncate max-w-xs transition-colors ${
                                  idx === historyIndex
                                    ? `${currentTheme.accent} text-white`
                                    : currentTheme.button
                                }`}
                                title={dir}
                              >
                                {dir.split(/[\\/]/).pop() || dir}
                              </button>
                              <button
                                onClick={e => {
                                  e.stopPropagation()
                                  const newHistory = dirHistory.filter((_, i) => i !== idx)
                                  const newIndex = idx < historyIndex ? historyIndex - 1 : (idx === historyIndex ? Math.min(historyIndex, newHistory.length - 1) : historyIndex)
                                  updateActiveTab({ dirHistory: newHistory, historyIndex: Math.max(-1, newIndex) })
                                }}
                                className="absolute right-1 top-1/2 -translate-y-1/2 opacity-0 group-hover:opacity-100 text-xs hover:text-red-400 transition-opacity"
                                title={t('actions.remove')}
                              >
                                ‚úï
                              </button>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}

                    {recentDirs.length > 0 && (
                      <div>
                        <div className="flex items-center justify-between mb-2">
                          <span className={`text-sm font-medium ${currentTheme.textSecondary}`}>{t('navigation.recentlyAccessed')}</span>
                          <button
                            onClick={() => setRecentDirs([])}
                            className={`text-xs px-2 py-0.5 rounded ${currentTheme.button} hover:text-red-400`}
                            title={t('actions.clearAll')}
                          >
                            {t('actions.clearAll')}
                          </button>
                        </div>
                        <div className="flex flex-wrap gap-2 max-h-32 overflow-y-auto">
                          {recentDirs.map((dir, idx) => (
                            <div key={idx} className="group relative">
                              <button
                                onClick={() => {
                                  loadDir(dir)
                                  setShowHistoryPanel(false)
                                }}
                                className={`px-3 py-1 pr-6 rounded text-sm truncate max-w-xs transition-colors ${
                                  dir === selectedDir
                                    ? 'bg-emerald-500 text-white'
                                    : currentTheme.button
                                }`}
                                title={dir}
                              >
                                {dir.split(/[\\/]/).pop() || dir}
                              </button>
                              <button
                                onClick={e => {
                                  e.stopPropagation()
                                  setRecentDirs(prev => prev.filter((_, i) => i !== idx))
                                }}
                                className="absolute right-1 top-1/2 -translate-y-1/2 opacity-0 group-hover:opacity-100 text-xs hover:text-red-400 transition-opacity"
                                title={t('actions.remove')}
                              >
                                ‚úï
                              </button>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}

                    {dirHistory.length === 0 && recentDirs.length === 0 && (
                      <div className={`text-center ${currentTheme.textSecondary} py-4`}>
                        {t('navigation.noHistoryYet')}
                      </div>
                    )}
                  </div>
                </div>
              </div>
            )}
            <main>
              {loading ? (
                <div className="flex flex-col items-center justify-center py-20">
                  <div className={`animate-spin rounded-full h-16 w-16 border-b-4 ${currentTheme.accentText.replace('text-', 'border-')} mb-4`}></div>
                  <p className="text-lg font-medium">{t('app.scanningDirectory')}</p>
                </div>
              ) : allImages.length === 0 ? (
                <div className="flex flex-col items-center justify-center py-20 text-center">
                  <div className="text-8xl mb-6">üñºÔ∏è</div>
                  <h2 className="text-2xl font-medium mb-3">{t('images.noImagesFound')}</h2>
                  <p className={`${currentTheme.textSecondary} mb-8 max-w-md`}>
                    {t('images.selectDirectoryToStart')}
                  </p>
                  <button
                    onClick={handleDirSelect}
                    className={`flex items-center gap-2 px-6 py-3 ${currentTheme.accent} text-white rounded-lg transition-colors font-medium`}
                  >
                    üìÅ {t('actions.selectDirectory')}
                  </button>
                </div>
              ) : displayedImages.length === 0 ? (
                <div className="flex flex-col items-center justify-center py-20 text-center">
                  <div className="text-8xl mb-6">üîç</div>
                  <h2 className="text-2xl font-medium mb-3">
                    {t('images.noMatchesFound')}
                  </h2>
                  <p className={currentTheme.textSecondary}>
                    {t('images.tryAdjustingSearch')}
                  </p>
                </div>
              ) : (
                <WaterfallGrid
                  displayedImages={displayedImages}
                  onImageClick={handleImageClick}
                  onToggleSelection={handleToggleImageSelection}
                  onStar={handleStarImage}
                  deleteMode={deleteMode}
                  theme={currentTheme}
                  isSelected={isSelectedForDeletion}
                  loadMoreObserverRef={loadMoreObserverRef}
                  loadingMore={loadingMore}
                  hasMore={hasMore}
                  filteredImagesCount={filteredImages.length}
                  columnCount={columnCount}
                  showStarButton={showStarButton}
                  onContextMenu={handleMainContextMenu}
                  starVersion={starVersion}
                  retainImages={retainImages}
                />
              )}
            </main>
            <ImageModal
              selectedImage={selectedImage}
              filteredImages={filteredImages}
              onClose={handleModalClose}
              onDelete={handleBatchDelete}
              onOpenLocation={openFileLocation}
              onNavigate={setSelectedImage}
              onStar={handleStarImage}
              keybindings={keybindings}
              clickOutsideToClose={clickOutsideToClose}
              showActionFeedback={showActionFeedback}
              maxImageSize={maxImageSize}
              fromMosaicMode={showMosaicMode}
            />
            {showMosaicMode && (
              <MosaicMode
                images={filteredImages}
                onClose={() => setShowMosaicMode(false)}
                onImageClick={(img) => { setSelectedImage(img) }}
                keybindings={keybindings}
                enableAnimation={mosaicAnimation}
                mosaicAnimationType={mosaicAnimationType}
                mosaicAnimationDuration={mosaicAnimationDuration}
                mosaicTileSize={mosaicTileSize}
                setMosaicTileSize={setMosaicTileSize}
                mosaicImageCount={mosaicImageCount}
                setMosaicImageCount={setMosaicImageCount}
                mosaicControlMode={mosaicControlMode}
                currentWall={mosaicCurrentWall}
                setCurrentWall={setMosaicCurrentWall}
                mosaicLoopWalls={mosaicLoopWalls}
                selectedImage={selectedImage}
              />
            )}
            {deleteMode && selectedForDeletion.size > 0 && (
              <div className="fixed bottom-0 left-0 right-0 z-50 bg-gray-800/90 backdrop-blur-sm p-4 border-t border-gray-700">
                <div className="max-w-7xl mx-auto flex justify-between items-center">
                  <span className="text-white font-medium">
                    {t('images.imagesSelected', { count: selectedForDeletion.size })}
                  </span>
                  <button
                    onClick={() =>
                      handleBatchDelete(Array.from(selectedForDeletion))
                    }
                    className="px-6 py-2 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700 transition-colors"
                  >
                    {t('actions.deleteSelected')}
                  </button>
                </div>
              </div>
            )}
            {mainContextMenu && (
              <div
                className="fixed inset-0 z-50"
                onClick={closeMainContextMenu}
              >
                <div
                  className="fixed backdrop-blur-xl bg-black/60 border border-white/20 rounded-xl shadow-2xl py-2 z-[60] min-w-[180px]"
                  style={{ left: mainContextMenu.x, top: mainContextMenu.y }}
                  onClick={e => e.stopPropagation()}
                >
                  <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => { setSelectedImage(mainContextMenu.image); closeMainContextMenu() }}>{t('contextMenu.viewImage')}</button>
                  <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => { openFileLocation(mainContextMenu.image); closeMainContextMenu() }}>{t('contextMenu.openLocation')}</button>
                  <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={async () => { await window.electronAPI.copyImageToClipboard(mainContextMenu.image.fullPath); if (showActionFeedback) alert(t('prompts.copied')); closeMainContextMenu() }}>{t('viewer.copyToClipboard')}</button>
                  <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => { handleStarImage(mainContextMenu.image); closeMainContextMenu() }}>{t('star.starUnstar')}</button>
                  <div className="border-t border-white/20 my-1"></div>
                  <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => { handleBatchDelete([mainContextMenu.image.fullPath]); closeMainContextMenu() }}>{t('actions.delete')}</button>
                </div>
              </div>
            )}
            {showHelp && (
              <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50" onClick={() => setShowHelp(false)}>
                <div className={`p-6 rounded-xl max-w-2xl max-h-[80vh] overflow-y-auto ${darkMode ? 'bg-gray-800 text-white' : 'bg-white text-gray-900'}`} onClick={e => e.stopPropagation()}>
                  <h2 className="text-xl font-bold mb-4">{t('help.title')}</h2>

                  <h3 className="text-md font-semibold mb-2 text-blue-400">{t('help.imageViewer')}</h3>
                  <div className="grid grid-cols-2 gap-2 text-sm mb-4">
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.prevImage)}</kbd> / <kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.nextImage)}</kbd> {t('help.navigate')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.zoomIn)}</kbd> / <kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.zoomOut)}</kbd> {t('help.zoom')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.resetZoom)}</kbd> {t('viewer.resetZoom')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.toggleDragMode)}</kbd> {t(KEYBINDING_LABELS.toggleDragMode)}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.toggleSlideshow)}</kbd> {t('viewer.slideshow')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.closeModal)}</kbd> {t('actions.close')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.deleteImage)}</kbd> {t('actions.delete')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.starImage)}</kbd> {t('star.starUnstar')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.copyToClipboard)}</kbd> {t('viewer.copyToClipboard')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.openLocation)}</kbd> {t('viewer.openFileLocation')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.cropImage)}</kbd> {t('viewer.crop')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.resizeImage)}</kbd> {t('viewer.resize')}</p>
                  </div>

                  <h3 className="text-md font-semibold mb-2 text-green-400">{t('help.mainWindow')}</h3>
                  <div className="grid grid-cols-2 gap-2 text-sm mb-4">
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">Ctrl+{formatKey(keybindings.openDirectory)}</kbd> {t('help.openDirectory')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">Ctrl+{formatKey(keybindings.newTab)}</kbd> {t('navigation.newTab')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">Ctrl+{formatKey(keybindings.closeTab)}</kbd> {t('navigation.closeTab')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.viewFavorites)}</kbd> {t('star.viewStarred')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.toggleDeleteMode)}</kbd> {t('deleteMode.selectToDelete')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.toggleDarkMode)}</kbd> {t('darkMode.toggle')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.toggleHistoryPanel)}</kbd> {t('navigation.historyAndRecent')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.toggleMosaicMode)}</kbd> {t('mosaic.title')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.openSettings)}</kbd> {t('settings.title')}</p>
                  </div>

                  <h3 className="text-md font-semibold mb-2 text-yellow-400">{t('help.other')}</h3>
                  <ul className="text-sm space-y-1 list-disc list-inside">
                    <li>{t('help.dragDropFolders')}</li>
                    <li>{t('help.scrollWheelZoom')}</li>
                    <li>{t('help.mouseBackForward')}</li>
                    <li>{t('help.rightClickMenu')}</li>
                  </ul>
                  <button onClick={() => setShowHelp(false)} className="mt-4 w-full py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600">{t('actions.close')}</button>
                </div>
              </div>
            )}
            {showSettings && (
              <SettingsModal
                theme={theme}
                currentTheme={currentTheme}
                setTheme={setTheme}
                showSettings={showSettings}
                setShowSettings={setShowSettings}
                clickOutsideToClose={clickOutsideToClose}
                setClickOutsideToClose={setClickOutsideToClose}
                confirmPrompts={confirmPrompts}
                setConfirmPrompts={setConfirmPrompts}
                showActionFeedback={showActionFeedback}
                setShowActionFeedback={setShowActionFeedback}
                maxImageSize={maxImageSize}
                setMaxImageSize={setMaxImageSize}
                keybindings={keybindings}
                setKeybindings={setKeybindings}
                editingKey={editingKey}
                setEditingKey={setEditingKey}
                retainImages={retainImages}
                setRetainImages={setRetainImages}
                mosaicAnimation={mosaicAnimation}
                setMosaicAnimation={setMosaicAnimation}
                mosaicAnimationType={mosaicAnimationType}
                setMosaicAnimationType={setMosaicAnimationType}
                mosaicAnimationDuration={mosaicAnimationDuration}
                setMosaicAnimationDuration={setMosaicAnimationDuration}
                mosaicTileSize={mosaicTileSize}
                setMosaicTileSize={setMosaicTileSize}
                mosaicImageCount={mosaicImageCount}
                setMosaicImageCount={setMosaicImageCount}
                mosaicControlMode={mosaicControlMode}
                setMosaicControlMode={setMosaicControlMode}
                mosaicLoopWalls={mosaicLoopWalls}
                setMosaicLoopWalls={setMosaicLoopWalls}
              />
            )}
          </div>
        )
      }

      const SettingsModal = ({
        theme,
        currentTheme,
        setTheme,
        showSettings,
        setShowSettings,
        clickOutsideToClose,
        setClickOutsideToClose,
        confirmPrompts,
        setConfirmPrompts,
        showActionFeedback,
        setShowActionFeedback,
        maxImageSize,
        setMaxImageSize,
        keybindings,
        setKeybindings,
        editingKey,
        setEditingKey,
        retainImages,
        setRetainImages,
        mosaicAnimation,
        setMosaicAnimation,
        mosaicAnimationType,
        setMosaicAnimationType,
        mosaicAnimationDuration,
        setMosaicAnimationDuration,
        mosaicTileSize,
        setMosaicTileSize,
        mosaicImageCount,
        setMosaicImageCount,
        mosaicControlMode,
        setMosaicControlMode,
        mosaicLoopWalls,
        setMosaicLoopWalls
      }) => {
        const { t, locale, setLocale, availableLocales } = useI18n()
        return (
          <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50" onClick={() => { setShowSettings(false); setEditingKey(null) }}>
            <div className={`p-6 rounded-xl max-w-lg w-full mx-4 max-h-[90vh] overflow-y-auto ${currentTheme.bgSecondary} ${currentTheme.text}`} onClick={e => e.stopPropagation()}>
              <h2 className="text-xl font-bold mb-4">{t('settings.title')}</h2>

              <h3 className="text-lg font-semibold mb-3">{t('settings.appearance')}</h3>
              <div className={`mb-4 p-3 rounded-lg ${currentTheme.bg}`}>
                <div className="grid grid-cols-4 gap-2">
                  {Object.entries(THEMES).map(([key, th]) => (
                    <button
                      key={key}
                      onClick={() => setTheme(key)}
                      className={`p-2 rounded-lg text-xs font-medium transition-all ${
                        theme === key ? 'ring-2 ring-offset-2 ring-blue-500' : ''
                      } ${th.bg} ${th.text}`}
                      title={th.name}
                    >
                      <div className={`h-4 w-full rounded mb-1 bg-gradient-to-r ${th.gradient}`}></div>
                      {th.name}
                    </button>
                  ))}
                </div>
              </div>

              <h3 className="text-lg font-semibold mb-3">{t('settings.behavior')}</h3>
              <div className={`flex items-center justify-between py-2 border-b ${currentTheme.border}`}>
                <span>{t('settings.language')}</span>
                <select
                  value={locale}
                  onChange={e => setLocale(e.target.value)}
                  className={`px-3 py-1 rounded ${currentTheme.button}`}
                >
                  {availableLocales.map(loc => (
                    <option key={loc} value={loc}>{LOCALE_NAMES[loc] || loc}</option>
                  ))}
                </select>
              </div>
              <div className={`flex items-center justify-between py-2 border-b ${currentTheme.border}`}>
                <span>{t('settings.clickOutsideToClose')}</span>
                <button
                  onClick={() => setClickOutsideToClose(v => !v)}
                  className={`px-3 py-1 rounded ${clickOutsideToClose ? 'bg-emerald-500 text-white' : currentTheme.button}`}
                >
                  {clickOutsideToClose ? t('settings.on') : t('settings.off')}
                </button>
              </div>
              <div className={`flex items-center justify-between py-2 border-b ${currentTheme.border}`}>
                <span>{t('settings.confirmationPrompts')}</span>
                <button
                  onClick={() => setConfirmPrompts(v => !v)}
                  className={`px-3 py-1 rounded ${confirmPrompts ? 'bg-emerald-500 text-white' : currentTheme.button}`}
                >
                  {confirmPrompts ? t('settings.on') : t('settings.off')}
                </button>
              </div>
              <div className={`flex items-center justify-between py-2 border-b ${currentTheme.border}`}>
                <span>{t('settings.showActionFeedback')}</span>
                <button
                  onClick={() => setShowActionFeedback(v => !v)}
                  className={`px-3 py-1 rounded ${showActionFeedback ? 'bg-emerald-500 text-white' : currentTheme.button}`}
                >
                  {showActionFeedback ? t('settings.on') : t('settings.off')}
                </button>
              </div>
              <div className={`flex items-center justify-between py-2 border-b ${currentTheme.border}`}>
                <span>{t('settings.maxImageSize')}</span>
                <div className="flex items-center gap-2">
                  <input
                    type="range"
                    min="50"
                    max="100"
                    value={maxImageSize}
                    onChange={e => setMaxImageSize(parseInt(e.target.value))}
                    className="w-24"
                  />
                  <span className="w-10 text-right">{maxImageSize}%</span>
                </div>
              </div>
              <div className={`flex items-center justify-between py-2 mb-4 border-b ${currentTheme.border}`}>
                <span>{t('settings.retainImages')}</span>
                <button
                  onClick={() => setRetainImages(v => !v)}
                  className={`px-3 py-1 rounded ${retainImages ? 'bg-emerald-500 text-white' : currentTheme.button}`}
                >
                  {retainImages ? t('settings.on') : t('settings.off')}
                </button>
              </div>
              <div className={`flex items-center justify-between py-2 border-b ${currentTheme.border}`}>
                <span>{t('mosaic.enableAnimation')}</span>
                <button
                  onClick={() => setMosaicAnimation(v => !v)}
                  className={`px-3 py-1 rounded ${mosaicAnimation ? 'bg-emerald-500 text-white' : currentTheme.button}`}
                >
                  {mosaicAnimation ? t('settings.on') : t('settings.off')}
                </button>
              </div>
              {mosaicAnimation && (
                <>
                  <div className={`flex items-center justify-between py-2 border-b ${currentTheme.border}`}>
                    <span>{t('mosaic.animationType')}</span>
                    <select
                      value={mosaicAnimationType}
                      onChange={e => setMosaicAnimationType(e.target.value)}
                      className={`px-3 py-1 rounded ${currentTheme.button}`}
                    >
                      <option value="fade">{t('mosaic.animationFade')}</option>
                      <option value="slide">{t('mosaic.animationSlide')}</option>
                    </select>
                  </div>
                  <div className={`flex items-center justify-between py-2 border-b ${currentTheme.border}`}>
                    <span>{t('mosaic.animationDuration')}</span>
                    <div className="flex items-center gap-2">
                      <input
                        type="range"
                        min="100"
                        max="800"
                        step="50"
                        value={mosaicAnimationDuration}
                        onChange={e => setMosaicAnimationDuration(parseInt(e.target.value))}
                        className="w-20"
                      />
                      <span className="w-14 text-right">{mosaicAnimationDuration}ms</span>
                    </div>
                  </div>
                </>
              )}
              <div className={`flex items-center justify-between py-2 border-b ${currentTheme.border}`}>
                <span>{t('mosaic.defaultTileSize')}</span>
                <div className="flex items-center gap-2">
                  <input
                    type="range"
                    min="100"
                    max="400"
                    step="20"
                    value={mosaicTileSize}
                    onChange={e => setMosaicTileSize(parseInt(e.target.value))}
                    className="w-20"
                  />
                  <span className="w-14 text-right">{mosaicTileSize}px</span>
                </div>
              </div>
              <div className={`flex items-center justify-between py-2 border-b ${currentTheme.border}`}>
                <span>{t('mosaic.controlMode')}</span>
                <div className="flex gap-2">
                  <button
                    onClick={() => setMosaicControlMode('tileSize')}
                    className={`px-3 py-1 rounded text-sm ${mosaicControlMode === 'tileSize' ? 'bg-emerald-500 text-white' : currentTheme.button}`}
                  >
                    {t('mosaic.tileSize')}
                  </button>
                  <button
                    onClick={() => setMosaicControlMode('imageCount')}
                    className={`px-3 py-1 rounded text-sm ${mosaicControlMode === 'imageCount' ? 'bg-emerald-500 text-white' : currentTheme.button}`}
                  >
                    {t('mosaic.imageCount')}
                  </button>
                </div>
              </div>
              {mosaicControlMode === 'imageCount' && (
                <div className={`flex items-center justify-between py-2 border-b ${currentTheme.border}`}>
                  <span>{t('mosaic.imagesPerWall')}</span>
                  <div className="flex items-center gap-2">
                    <input
                      type="range"
                      min="4"
                      max="100"
                      step="1"
                      value={mosaicImageCount}
                      onChange={e => setMosaicImageCount(parseInt(e.target.value))}
                      className="w-20"
                    />
                    <span className="w-10 text-right">{mosaicImageCount}</span>
                  </div>
                </div>
              )}
              <div className={`flex items-center justify-between py-2 mb-4 border-b ${currentTheme.border}`}>
                <span>{t('mosaic.loopWalls')}</span>
                <button
                  onClick={() => setMosaicLoopWalls(v => !v)}
                  className={`px-3 py-1 rounded ${mosaicLoopWalls ? 'bg-emerald-500 text-white' : currentTheme.button}`}
                >
                  {mosaicLoopWalls ? t('settings.on') : t('settings.off')}
                </button>
              </div>

              <h3 className="text-lg font-semibold mb-3">{t('settings.keybindings')}</h3>
              <div className="space-y-2 max-h-48 overflow-y-auto">
                {Object.keys(keybindings).map(action => (
                  <div key={action} className={`flex items-center justify-between py-2 border-b ${currentTheme.border}`}>
                    <span>{t(KEYBINDING_LABELS[action])}</span>
                    <button
                      onClick={() => setEditingKey(action)}
                      className={`px-3 py-1 rounded ${editingKey === action ? 'bg-blue-500 text-white animate-pulse' : currentTheme.button}`}
                      onKeyDown={e => {
                        if (editingKey === action) {
                          e.preventDefault()
                          setKeybindings(prev => ({ ...prev, [action]: e.key }))
                          setEditingKey(null)
                        }
                      }}
                    >
                      {editingKey === action ? '...' : formatKey(keybindings[action])}
                    </button>
                  </div>
                ))}
              </div>
              <div className="flex gap-2 mt-4">
                <button
                  onClick={() => { setKeybindings(DEFAULT_KEYBINDINGS); setEditingKey(null) }}
                  className={`flex-1 py-2 rounded-lg ${currentTheme.button}`}
                >
                  {t('actions.resetToDefault')}
                </button>
                <button
                  onClick={() => { setShowSettings(false); setEditingKey(null) }}
                  className={`flex-1 py-2 rounded-lg ${currentTheme.accent} text-white`}
                >
                  {t('actions.done')}
                </button>
              </div>
            </div>
          </div>
        )
      }

      window.path = { basename: filepath => filepath.split(/[\\/]/).pop() }
      ReactDOM.render(<I18nProvider><ImageViewerApp /></I18nProvider>, document.getElementById('root'))
    </script>
  </body>
</html>
