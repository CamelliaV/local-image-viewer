<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hanasato</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto',
          sans-serif;
      }
      .app-container {
        height: 100vh;
        overflow-y: auto;
        overflow-x: hidden;
      }
      .app-container::-webkit-scrollbar {
        width: 8px;
      }
      .app-container::-webkit-scrollbar-track {
        background: #f1f1f1;
      }
      .app-container::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 4px;
      }
      .app-container::-webkit-scrollbar-thumb:hover {
        background: #555;
      }
      .waterfall-container {
        display: flex;
        gap: 12px;
        padding: 16px;
        align-items: flex-start;
        overflow-x: auto;
      }
      .waterfall-column {
        flex: 1 0 180px;
        min-width: 180px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .image-card {
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        transition: all 0.2s ease;
        cursor: pointer;
        position: relative;
        display: flex;
        flex-direction: column;
      }
      .image-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
      }
      .image-card img {
        width: 100%;
        height: auto;
        max-height: 400px;
        object-fit: cover;
        display: block;
      }
      .placeholder-card {
        background: linear-gradient(
          90deg,
          #f0f0f0 25%,
          #e0e0e0 50%,
          #f0f0f0 75%
        );
        background-size: 200% 100%;
        animation: shimmer 1.5s infinite;
        border-radius: 12px;
        height: 200px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #999;
      }
      @keyframes shimmer {
        0% {
          background-position: -200% 0;
        }
        100% {
          background-position: 200% 0;
        }
      }
      .load-more-trigger {
        height: 100px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 20px 0;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script>
      console.log('Script starting - React:', typeof React, 'ReactDOM:', typeof ReactDOM)
    </script>
    <script type="text/babel">
      const { useState, useEffect, useCallback, useRef, useMemo, createContext, useContext } = React
      const BATCH_SIZE = 20
      const COLUMN_COUNT = 4

      // --- i18n System ---
      const I18nContext = createContext({ t: key => key, locale: 'en', setLocale: () => {}, availableLocales: ['en'] })

      const useI18n = () => useContext(I18nContext)

      const I18nProvider = ({ children }) => {
        const [translations, setTranslations] = useState({})
        const [locale, setLocaleState] = useState(() => localStorage.getItem('locale') || '')
        const [availableLocales, setAvailableLocales] = useState(['en'])
        const [initialized, setInitialized] = useState(false)

        useEffect(() => {
          const initLocale = async () => {
            const locales = await window.electronAPI.getAvailableLocales()
            setAvailableLocales(locales)

            let targetLocale = localStorage.getItem('locale')
            if (!targetLocale) {
              targetLocale = await window.electronAPI.getSystemLocale()
            }
            const { locale: resolvedLocale, data } = await window.electronAPI.getLocaleData(targetLocale)
            setTranslations(data)
            setLocaleState(resolvedLocale)
            setInitialized(true)
          }
          initLocale()
        }, [])

        const setLocale = useCallback(async (newLocale) => {
          const { locale: resolvedLocale, data } = await window.electronAPI.getLocaleData(newLocale)
          setTranslations(data)
          setLocaleState(resolvedLocale)
          localStorage.setItem('locale', resolvedLocale)
        }, [])

        const t = useCallback((key, params = {}) => {
          const keys = key.split('.')
          let value = translations
          for (const k of keys) {
            if (value && typeof value === 'object' && k in value) {
              value = value[k]
            } else {
              return key // Return key if translation not found
            }
          }
          if (typeof value !== 'string') return key
          // Replace {param} placeholders
          return value.replace(/\{(\w+)\}/g, (_, name) => params[name] ?? `{${name}}`)
        }, [translations])

        if (!initialized) {
          return <div className="flex items-center justify-center h-screen bg-gray-900 text-white">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
          </div>
        }

        return (
          <I18nContext.Provider value={{ t, locale, setLocale, availableLocales }}>
            {children}
          </I18nContext.Provider>
        )
      }

      const LOCALE_NAMES = {
        'en': 'English',
        'zh-CN': 'ÁÆÄ‰Ωì‰∏≠Êñá',
        'ja': 'Êó•Êú¨Ë™û'
      }

      // Stylish theme definitions
      const THEMES = {
        midnight: {
          name: 'Midnight',
          bg: 'bg-gray-950',
          bgSecondary: 'bg-gray-900',
          text: 'text-gray-100',
          textSecondary: 'text-gray-400',
          border: 'border-gray-800',
          card: 'bg-gray-900',
          accent: 'bg-violet-600 hover:bg-violet-700',
          accentText: 'text-violet-400',
          header: 'bg-gray-900/95',
          input: 'bg-gray-800 border-gray-700 text-white placeholder-gray-500',
          button: 'bg-gray-800 hover:bg-gray-700',
          gradient: 'from-violet-600 to-fuchsia-600'
        },
        sakura: {
          name: 'Sakura',
          bg: 'bg-pink-50',
          bgSecondary: 'bg-white',
          text: 'text-gray-800',
          textSecondary: 'text-pink-600',
          border: 'border-pink-200',
          card: 'bg-white',
          accent: 'bg-pink-500 hover:bg-pink-600',
          accentText: 'text-pink-500',
          header: 'bg-white/95',
          input: 'bg-white border-pink-300 text-gray-800 placeholder-pink-400',
          button: 'bg-pink-100 hover:bg-pink-200',
          gradient: 'from-pink-500 to-rose-500'
        },
        ocean: {
          name: 'Ocean',
          bg: 'bg-slate-900',
          bgSecondary: 'bg-slate-800',
          text: 'text-cyan-50',
          textSecondary: 'text-cyan-400',
          border: 'border-slate-700',
          card: 'bg-slate-800',
          accent: 'bg-cyan-500 hover:bg-cyan-600',
          accentText: 'text-cyan-400',
          header: 'bg-slate-800/95',
          input: 'bg-slate-700 border-slate-600 text-white placeholder-slate-400',
          button: 'bg-slate-700 hover:bg-slate-600',
          gradient: 'from-cyan-500 to-blue-600'
        },
        forest: {
          name: 'Forest',
          bg: 'bg-emerald-950',
          bgSecondary: 'bg-emerald-900',
          text: 'text-emerald-50',
          textSecondary: 'text-emerald-400',
          border: 'border-emerald-800',
          card: 'bg-emerald-900',
          accent: 'bg-emerald-500 hover:bg-emerald-600',
          accentText: 'text-emerald-400',
          header: 'bg-emerald-900/95',
          input: 'bg-emerald-800 border-emerald-700 text-white placeholder-emerald-500',
          button: 'bg-emerald-800 hover:bg-emerald-700',
          gradient: 'from-emerald-500 to-teal-500'
        },
        sunset: {
          name: 'Sunset',
          bg: 'bg-orange-50',
          bgSecondary: 'bg-white',
          text: 'text-gray-800',
          textSecondary: 'text-orange-600',
          border: 'border-orange-200',
          card: 'bg-white',
          accent: 'bg-orange-500 hover:bg-orange-600',
          accentText: 'text-orange-500',
          header: 'bg-white/95',
          input: 'bg-white border-orange-300 text-gray-800 placeholder-orange-400',
          button: 'bg-orange-100 hover:bg-orange-200',
          gradient: 'from-orange-500 to-amber-500'
        },
        neon: {
          name: 'Neon',
          bg: 'bg-black',
          bgSecondary: 'bg-zinc-900',
          text: 'text-white',
          textSecondary: 'text-fuchsia-400',
          border: 'border-fuchsia-900',
          card: 'bg-zinc-900',
          accent: 'bg-fuchsia-600 hover:bg-fuchsia-500',
          accentText: 'text-fuchsia-400',
          header: 'bg-zinc-900/95',
          input: 'bg-zinc-800 border-fuchsia-800 text-white placeholder-zinc-500',
          button: 'bg-zinc-800 hover:bg-zinc-700',
          gradient: 'from-fuchsia-500 to-cyan-400'
        },
        lavender: {
          name: 'Lavender',
          bg: 'bg-purple-50',
          bgSecondary: 'bg-white',
          text: 'text-gray-800',
          textSecondary: 'text-purple-600',
          border: 'border-purple-200',
          card: 'bg-white',
          accent: 'bg-purple-500 hover:bg-purple-600',
          accentText: 'text-purple-500',
          header: 'bg-white/95',
          input: 'bg-white border-purple-300 text-gray-800 placeholder-purple-400',
          button: 'bg-purple-100 hover:bg-purple-200',
          gradient: 'from-purple-500 to-indigo-500'
        },
        noir: {
          name: 'Noir',
          bg: 'bg-neutral-950',
          bgSecondary: 'bg-neutral-900',
          text: 'text-neutral-100',
          textSecondary: 'text-neutral-400',
          border: 'border-neutral-800',
          card: 'bg-neutral-900',
          accent: 'bg-neutral-700 hover:bg-neutral-600',
          accentText: 'text-neutral-300',
          header: 'bg-neutral-900/95',
          input: 'bg-neutral-800 border-neutral-700 text-white placeholder-neutral-500',
          button: 'bg-neutral-800 hover:bg-neutral-700',
          gradient: 'from-neutral-600 to-neutral-400'
        }
      }

      const DEFAULT_KEYBINDINGS = {
        // Image viewer navigation
        prevImage: 'ArrowLeft',
        nextImage: 'ArrowRight',
        closeModal: 'Escape',
        // Zoom controls
        zoomIn: '+',
        zoomOut: '-',
        resetZoom: '0',
        toggleDragMode: 'd',
        // Actions
        toggleSlideshow: ' ',
        deleteImage: 'Delete',
        starImage: 's',
        copyToClipboard: 'c',
        openLocation: 'l',
        // Edit modes
        cropImage: 'x',
        resizeImage: 'r',
        // Main window
        openDirectory: 'o',
        viewFavorites: 'f',
        toggleDeleteMode: 'Backspace',
        newTab: 't',
        closeTab: 'w',
        toggleDarkMode: 'm',
        openSettings: ',',
        openHelp: '?',
        toggleHistoryPanel: 'h'
      }

      const KEYBINDING_LABELS = {
        prevImage: 'keybindingLabels.prevImage',
        nextImage: 'keybindingLabels.nextImage',
        closeModal: 'keybindingLabels.closeModal',
        zoomIn: 'keybindingLabels.zoomIn',
        zoomOut: 'keybindingLabels.zoomOut',
        resetZoom: 'keybindingLabels.resetZoom',
        toggleDragMode: 'keybindingLabels.toggleDragMode',
        toggleSlideshow: 'keybindingLabels.toggleSlideshow',
        deleteImage: 'keybindingLabels.deleteImage',
        starImage: 'keybindingLabels.starImage',
        copyToClipboard: 'keybindingLabels.copyToClipboard',
        openLocation: 'keybindingLabels.openLocation',
        cropImage: 'keybindingLabels.cropImage',
        resizeImage: 'keybindingLabels.resizeImage',
        openDirectory: 'keybindingLabels.openDirectory',
        viewFavorites: 'keybindingLabels.viewFavorites',
        toggleDeleteMode: 'keybindingLabels.toggleDeleteMode',
        newTab: 'keybindingLabels.newTab',
        closeTab: 'keybindingLabels.closeTab',
        toggleDarkMode: 'keybindingLabels.toggleDarkMode',
        openSettings: 'keybindingLabels.openSettings',
        openHelp: 'keybindingLabels.openHelp',
        toggleHistoryPanel: 'keybindingLabels.toggleHistoryPanel'
      }

      const formatKey = key => key === ' ' ? 'Space' : key

      const formatFileSize = bytes => {
        if (bytes === 0) return '0 Bytes'
        const k = 1024
        const sizes = ['Bytes', 'KB', 'MB', 'GB']
        const i = Math.floor(Math.log(bytes) / Math.log(k))
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
      }

      const ImageCard = React.memo(
        ({
          image,
          onImageClick,
          onToggleSelection,
          onStar,
          deleteMode,
          theme,
          isSelected,
          showStarButton,
          onContextMenu,
          starVersion,
          retainImages
        }) => {
          const { t } = useI18n()
          const [imageLoaded, setImageLoaded] = useState(() => retainImages && loadedImagesCache.has(image.fullPath))
          const [imageError, setImageError] = useState(false)
          const [isStarred, setIsStarred] = useState(false)
          const handleImageLoad = useCallback(() => {
            setImageLoaded(true)
            if (retainImages) loadedImagesCache.add(image.fullPath)
          }, [image.fullPath, retainImages])
          const handleImageError = useCallback(() => setImageError(true), [])
          const handleClick = useCallback(() => {
            if (deleteMode) {
              onToggleSelection(image)
            } else {
              onImageClick(image)
            }
          }, [deleteMode, image, onToggleSelection, onImageClick])

          useEffect(() => {
            window.electronAPI.isImageStarred(image.fullPath).then(setIsStarred)
          }, [image.fullPath, starVersion])

          const handleStar = useCallback(async e => {
            e.stopPropagation()
            await onStar(image)
            const starred = await window.electronAPI.isImageStarred(image.fullPath)
            setIsStarred(starred)
          }, [image, onStar])

          if (imageError) {
            return (
              <div
                className={`image-card ${theme.card}`}
                style={{ height: '150px' }}
              >
                <div className={`h-full flex flex-col items-center justify-center ${theme.textSecondary}`}>
                  <div className="text-2xl mb-2">‚ùå</div>
                  <div className="text-sm">{t('app.failedToLoad')}</div>
                </div>
              </div>
            )
          }

          const handleContextMenuEvent = useCallback(e => {
            e.preventDefault()
            onContextMenu(e, image)
          }, [image, onContextMenu])

          return (
            <div
              className={`image-card group ${theme.card}`}
              onClick={handleClick}
              onContextMenu={handleContextMenuEvent}
            >
              {!imageLoaded && (
                <div className="placeholder-card">
                  <div className="text-center">
                    <div className="text-2xl mb-2">üñºÔ∏è</div>
                    <div className="text-sm">{t('app.loading')}</div>
                  </div>
                </div>
              )}
              <div
                className={`relative transition-all duration-200 ${
                  isSelected ? 'ring-4 ring-blue-500' : ''
                }`}
              >
                <img
                  src={image.url}
                  alt={image.name}
                  onLoad={handleImageLoad}
                  onError={handleImageError}
                  className={`transition-opacity duration-300 ${
                    imageLoaded ? 'opacity-100' : 'opacity-0 absolute inset-0'
                  }`}
                />
                {isSelected && (
                  <div className="absolute inset-0 bg-blue-500 bg-opacity-40 flex items-center justify-center text-white text-4xl font-bold">
                    ‚úì
                  </div>
                )}
                {showStarButton && !deleteMode && (
                  <button
                    onClick={handleStar}
                    className={`absolute top-2 right-2 bg-black bg-opacity-50 p-1.5 rounded-full transition-opacity hover:bg-opacity-70 ${isStarred ? 'opacity-100 text-yellow-400' : 'opacity-0 group-hover:opacity-100 text-gray-400'}`}
                    title={isStarred ? t('star.unstarImage') : t('star.starImage')}
                  >
                    {isStarred ? '‚≠ê' : '‚òÜ'}
                  </button>
                )}
              </div>
              <div className="p-2 text-left">
                <div className="font-medium text-sm truncate">{image.name}</div>
                <div className={`text-xs ${theme.textSecondary}`}>
                  {formatFileSize(image.size)}
                </div>
              </div>
            </div>
          )
        }
      )

      const loadedImagesCache = new Set()

      const WaterfallGrid = React.memo(
        ({
          displayedImages,
          onImageClick,
          onToggleSelection,
          onStar,
          deleteMode,
          theme,
          isSelected,
          loadMoreObserverRef,
          loadingMore,
          hasMore,
          filteredImagesCount,
          columnCount,
          showStarButton,
          onContextMenu,
          starVersion,
          retainImages
        }) => {
          const { t } = useI18n()
          const columns = useMemo(() => {
            const cols = Array.from({ length: columnCount }, () => [])
            displayedImages.forEach((image, index) => {
              cols[index % columnCount].push(image)
            })
            return cols
          }, [displayedImages, columnCount])
          return (
            <div>
              <div className="waterfall-container">
                {columns.map((columnImages, columnIndex) => (
                  <div key={columnIndex} className="waterfall-column">
                    {columnImages.map(image => (
                      <ImageCard
                        key={image.fullPath}
                        image={image}
                        onImageClick={onImageClick}
                        onToggleSelection={onToggleSelection}
                        onStar={onStar}
                        deleteMode={deleteMode}
                        theme={theme}
                        isSelected={isSelected(image)}
                        showStarButton={showStarButton}
                        onContextMenu={onContextMenu}
                        starVersion={starVersion}
                        retainImages={retainImages}
                      />
                    ))}
                  </div>
                ))}
              </div>
              {hasMore && (
                <div ref={loadMoreObserverRef} className="load-more-trigger">
                  {loadingMore ? (
                    <div className="flex items-center gap-2">
                      <div className={`animate-spin rounded-full h-6 w-6 border-b-2 ${theme.accentText.replace('text-', 'border-')}`}></div>
                      <span>{t('images.loadingMore')}</span>
                    </div>
                  ) : (
                    <div className={theme.textSecondary}>{t('images.loadingMore')}</div>
                  )}
                </div>
              )}
              {!hasMore && displayedImages.length > 0 && (
                <div className={`text-center py-8 ${theme.textSecondary}`}>
                  üéâ {t('images.allImagesLoaded', { count: filteredImagesCount })}
                </div>
              )}
            </div>
          )
        }
      )

      const ImageModal = React.memo(
        ({
          selectedImage,
          filteredImages,
          onClose,
          onDelete,
          onOpenLocation,
          onNavigate,
          onStar,
          keybindings,
          clickOutsideToClose,
          showActionFeedback,
          maxImageSize
        }) => {
          const { t } = useI18n()
          const [zoom, setZoom] = useState(1)
          const [position, setPosition] = useState({ x: 0, y: 0 })
          const [isDragging, setIsDragging] = useState(false)
          const [dragMode, setDragMode] = useState(false)
          const dragStartRef = useRef({ x: 0, y: 0 })
          const positionRef = useRef({ x: 0, y: 0 })
          const zoomRef = useRef(1)
          const [dimensions, setDimensions] = useState(null)
          const [slideshow, setSlideshow] = useState(false)
          const [editMode, setEditMode] = useState(null) // 'crop' | 'resize' | null
          const [cropArea, setCropArea] = useState(null)
          const [resizeW, setResizeW] = useState('')
          const [resizeH, setResizeH] = useState('')
          const [contextMenu, setContextMenu] = useState(null)
          const imageRef = useRef(null)
          const canvasRef = useRef(null)

          useEffect(() => {
            setZoom(1)
            zoomRef.current = 1
            setPosition({ x: 0, y: 0 })
            positionRef.current = { x: 0, y: 0 }
            setDimensions(null)
            setEditMode(null)
            setDragMode(false)
            setCropArea(null)
            setContextMenu(null)
          }, [selectedImage?.fullPath])

          const currentIndex = useMemo(
            () =>
              selectedImage
                ? filteredImages.findIndex(
                    img => img.fullPath === selectedImage.fullPath
                  )
                : -1,
            [filteredImages, selectedImage]
          )

          useEffect(() => {
            if (!slideshow || !selectedImage) return
            const timer = setInterval(() => {
              if (currentIndex < filteredImages.length - 1) {
                onNavigate(filteredImages[currentIndex + 1])
              } else {
                onNavigate(filteredImages[0])
              }
            }, 3000)
            return () => clearInterval(timer)
          }, [slideshow, selectedImage, filteredImages, onNavigate, currentIndex])

          const showPrevious = useCallback(() => {
            if (currentIndex > 0) onNavigate(filteredImages[currentIndex - 1])
          }, [currentIndex, filteredImages, onNavigate])
          const showNext = useCallback(() => {
            if (currentIndex < filteredImages.length - 1)
              onNavigate(filteredImages[currentIndex + 1])
          }, [currentIndex, filteredImages, onNavigate])

          const handleWheel = useCallback(e => {
            e.preventDefault()
            const delta = e.deltaY > 0 ? 0.9 : 1.1
            setZoom(z => {
              const newZoom = Math.min(Math.max(z * delta, 0.5), 5)
              zoomRef.current = newZoom
              return newZoom
            })
          }, [])

          const handleMouseDown = useCallback(e => {
            // Allow drag when in drag mode (no zoom requirement)
            if (dragMode && !editMode) {
              e.preventDefault()
              e.stopPropagation()
              setIsDragging(true)
              dragStartRef.current = { x: e.clientX - positionRef.current.x, y: e.clientY - positionRef.current.y }
            }
          }, [editMode, dragMode])

          const handleMouseMove = useCallback(e => {
            if (isDragging) {
              const newPos = { x: e.clientX - dragStartRef.current.x, y: e.clientY - dragStartRef.current.y }
              positionRef.current = newPos
              setPosition(newPos)
            }
          }, [isDragging])

          const handleMouseUp = useCallback(() => {
            setIsDragging(false)
          }, [])

          const handleContextMenu = useCallback(e => {
            e.preventDefault()
            setContextMenu({ x: e.clientX, y: e.clientY })
          }, [])

          const closeContextMenu = useCallback(() => setContextMenu(null), [])

          const handleCropStart = useCallback(e => {
            if (editMode !== 'crop' || !imageRef.current) return
            const rect = imageRef.current.getBoundingClientRect()
            const x = e.clientX - rect.left
            const y = e.clientY - rect.top
            setCropArea({ x, y, w: 0, h: 0, startX: x, startY: y })
          }, [editMode])

          const handleCropMove = useCallback(e => {
            if (!cropArea?.startX || !imageRef.current) return
            const rect = imageRef.current.getBoundingClientRect()
            const x = Math.max(0, Math.min(e.clientX - rect.left, rect.width))
            const y = Math.max(0, Math.min(e.clientY - rect.top, rect.height))
            setCropArea(prev => ({
              ...prev,
              x: Math.min(prev.startX, x),
              y: Math.min(prev.startY, y),
              w: Math.abs(x - prev.startX),
              h: Math.abs(y - prev.startY)
            }))
          }, [cropArea])

          const handleCropEnd = useCallback(() => {
            if (cropArea) setCropArea(prev => ({ ...prev, startX: null, startY: null }))
          }, [cropArea])

          const saveCrop = useCallback(async () => {
            if (!cropArea || !dimensions || !imageRef.current) return
            const rect = imageRef.current.getBoundingClientRect()
            const scaleX = dimensions.w / rect.width
            const scaleY = dimensions.h / rect.height
            const canvas = document.createElement('canvas')
            canvas.width = cropArea.w * scaleX
            canvas.height = cropArea.h * scaleY
            const ctx = canvas.getContext('2d')
            const img = new Image()
            img.crossOrigin = 'anonymous'
            img.onload = async () => {
              ctx.drawImage(img, cropArea.x * scaleX, cropArea.y * scaleY, canvas.width, canvas.height, 0, 0, canvas.width, canvas.height)
              const dataUrl = canvas.toDataURL('image/png')
              try {
                await window.electronAPI.saveEditedImage(selectedImage.fullPath, dataUrl, 'cropped')
                alert(t('prompts.croppedImageSaved'))
                setEditMode(null)
                setCropArea(null)
              } catch (err) { alert(t('prompts.error') + ': ' + err.message) }
            }
            img.src = selectedImage.url.replace('local-image://', 'file://')
          }, [cropArea, dimensions, selectedImage, t])

          const saveResize = useCallback(async () => {
            if (!resizeW || !resizeH || !dimensions) return
            const canvas = document.createElement('canvas')
            canvas.width = parseInt(resizeW)
            canvas.height = parseInt(resizeH)
            const ctx = canvas.getContext('2d')
            const img = new Image()
            img.crossOrigin = 'anonymous'
            img.onload = async () => {
              ctx.drawImage(img, 0, 0, canvas.width, canvas.height)
              const dataUrl = canvas.toDataURL('image/png')
              try {
                await window.electronAPI.saveEditedImage(selectedImage.fullPath, dataUrl, `${canvas.width}x${canvas.height}`)
                alert(t('prompts.resizedImageSaved'))
                setEditMode(null)
              } catch (err) { alert(t('prompts.error') + ': ' + err.message) }
            }
            img.src = selectedImage.url.replace('local-image://', 'file://')
          }, [resizeW, resizeH, dimensions, selectedImage, t])

          useEffect(() => {
            if (!selectedImage) return
            const handleKeyPress = async e => {
              const key = e.key
              if (key === keybindings.closeModal) onClose()
              else if (key === keybindings.prevImage) showPrevious()
              else if (key === keybindings.nextImage) showNext()
              else if (key === keybindings.zoomIn || key === '=') setZoom(z => { const nz = Math.min(z * 1.2, 5); zoomRef.current = nz; return nz })
              else if (key === keybindings.zoomOut) setZoom(z => { const nz = Math.max(z / 1.2, 0.5); zoomRef.current = nz; return nz })
              else if (key === keybindings.resetZoom) { setZoom(1); zoomRef.current = 1; setPosition({ x: 0, y: 0 }); positionRef.current = { x: 0, y: 0 }; setDragMode(false) }
              else if (key === keybindings.toggleDragMode || key === 'D') { setDragMode(d => !d) }
              else if (key === keybindings.toggleSlideshow) { e.preventDefault(); setSlideshow(s => !s) }
              else if (key === keybindings.deleteImage) { onDelete([selectedImage.fullPath]) }
              else if (key === keybindings.starImage || key === 'S') { onStar(selectedImage) }
              else if (key === keybindings.copyToClipboard || key === 'C') {
                try {
                  await window.electronAPI.copyImageToClipboard(selectedImage.fullPath)
                  if (showActionFeedback) alert(t('prompts.copied'))
                } catch (err) { alert(t('prompts.error') + ': ' + err.message) }
              }
              else if (key === keybindings.openLocation || key === 'L') { onOpenLocation(selectedImage) }
              else if (key === keybindings.cropImage || key === 'X') { setEditMode(editMode === 'crop' ? null : 'crop'); setCropArea(null) }
              else if (key === keybindings.resizeImage || key === 'R') { setEditMode(editMode === 'resize' ? null : 'resize'); if (dimensions) { setResizeW(String(dimensions.w)); setResizeH(String(dimensions.h)) } }
            }
            document.addEventListener('keydown', handleKeyPress)
            return () => document.removeEventListener('keydown', handleKeyPress)
          }, [onClose, showPrevious, showNext, selectedImage, keybindings, onDelete, onStar, onOpenLocation, showActionFeedback, editMode, dimensions])

          if (!selectedImage) return null

          const handleBackdropClick = e => {
            if (contextMenu) {
              setContextMenu(null)
              return
            }
            if (clickOutsideToClose && e.target === e.currentTarget && zoomRef.current <= 1) {
              onClose()
            }
          }

          return (
            <div
              className="fixed inset-0 backdrop-blur-md bg-black/70 flex items-center justify-center z-50"
              onMouseMove={handleMouseMove}
              onMouseUp={handleMouseUp}
              onMouseLeave={handleMouseUp}
              onMouseDown={handleMouseDown}
              onClick={handleBackdropClick}
            >
              <div className="relative w-full h-full flex items-center justify-center p-4" onClick={handleBackdropClick}>
                <div className="relative" onMouseDown={editMode === 'crop' ? handleCropStart : undefined} onMouseMove={editMode === 'crop' ? handleCropMove : undefined} onMouseUp={editMode === 'crop' ? handleCropEnd : undefined} onMouseLeave={editMode === 'crop' ? handleCropEnd : undefined} onClick={e => e.stopPropagation()}>
                  <img
                    ref={imageRef}
                    src={selectedImage.url}
                    alt={selectedImage.name}
                    className="object-contain select-none"
                    style={{
                      maxWidth: `${maxImageSize}vw`,
                      maxHeight: `${maxImageSize - 5}vh`,
                      transform: editMode ? 'none' : `scale(${zoom}) translate(${position.x / zoom}px, ${position.y / zoom}px)`,
                      cursor: editMode === 'crop' ? 'crosshair' : (dragMode ? (isDragging ? 'grabbing' : 'grab') : 'default'),
                      transition: isDragging ? 'none' : 'transform 0.1s ease-out'
                    }}
                    onWheel={editMode ? undefined : handleWheel}
                    onMouseDown={editMode ? undefined : handleMouseDown}
                    onLoad={e => setDimensions({ w: e.target.naturalWidth, h: e.target.naturalHeight })}
                    draggable={false}
                    onContextMenu={handleContextMenu}
                  />
                  {editMode === 'crop' && cropArea && (
                    <div
                      className="absolute border-2 border-dashed border-white bg-white bg-opacity-20 pointer-events-none"
                      style={{ left: cropArea.x, top: cropArea.y, width: cropArea.w, height: cropArea.h }}
                    />
                  )}
                </div>

                {contextMenu && (
                  <div
                    className="fixed backdrop-blur-xl bg-black/60 border border-white/20 rounded-xl shadow-2xl py-2 z-[60] min-w-[180px]"
                    style={{ left: contextMenu.x, top: contextMenu.y }}
                    onClick={closeContextMenu}
                  >
                    <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => onDelete([selectedImage.fullPath])}>{t('actions.delete')}</button>
                    <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => onOpenLocation(selectedImage)}>{t('contextMenu.openLocation')}</button>
                    <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={async () => { await window.electronAPI.copyImageToClipboard(selectedImage.fullPath); if (showActionFeedback) alert(t('prompts.copied')) }}>{t('viewer.copyToClipboard')}</button>
                    <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => onStar(selectedImage)}>{t('star.starUnstar')}</button>
                    <div className="border-t border-white/20 my-1"></div>
                    <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => setSlideshow(s => !s)}>{slideshow ? t('viewer.stopSlideshow') : t('viewer.startSlideshow')}</button>
                    <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => { setEditMode('crop'); setCropArea(null) }}>{t('viewer.crop')}</button>
                    <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => { setEditMode('resize'); if (dimensions) { setResizeW(String(dimensions.w)); setResizeH(String(dimensions.h)) } }}>{t('viewer.resize')}</button>
                    <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => {
                      const newName = prompt(t('prompts.enterNewFilename'), selectedImage.name)
                      if (newName && newName !== selectedImage.name) {
                        window.electronAPI.renameImage(selectedImage.fullPath, newName).then(() => { if (showActionFeedback) alert(t('prompts.fileCopiedNewName')) }).catch(err => alert(t('prompts.error') + ': ' + err.message))
                      }
                    }}>{t('actions.saveAs')}</button>
                    <div className="border-t border-white/20 my-1"></div>
                    <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => { setZoom(z => { const nz = Math.min(z * 1.2, 5); zoomRef.current = nz; return nz }) }}>{t('viewer.zoomIn')}</button>
                    <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => { setZoom(z => { const nz = Math.max(z / 1.2, 0.5); zoomRef.current = nz; return nz }) }}>{t('viewer.zoomOut')}</button>
                    <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => { setZoom(1); zoomRef.current = 1; setPosition({ x: 0, y: 0 }); positionRef.current = { x: 0, y: 0 }; setDragMode(false) }}>{t('viewer.resetZoom')}</button>
                    <button className={`w-full px-4 py-2 text-left text-sm transition-colors ${dragMode ? 'text-cyan-400 bg-white/5' : 'text-white'} hover:bg-white/10`} onClick={() => setDragMode(d => !d)}>{dragMode ? '‚úì ' + t('viewer.dragModeOn') : t('viewer.enableDragMode')}</button>
                    <div className="border-t border-white/20 my-1"></div>
                    <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={onClose}>{t('actions.close')}</button>
                  </div>
                )}

                <button
                  onClick={onClose}
                  className="absolute top-4 right-4 bg-black bg-opacity-60 text-white p-2 rounded-full hover:bg-opacity-80 transition-all text-xl"
                  title={t('viewer.closeEsc')}
                >
                  ‚úï
                </button>
                <button
                  onClick={() => onDelete([selectedImage.fullPath])}
                  className="absolute top-4 left-4 bg-red-500 bg-opacity-80 text-white p-2 rounded-full hover:bg-opacity-100 transition-all"
                  title={t('viewer.deleteImage')}
                >
                  üóëÔ∏è
                </button>
                <button
                  onClick={() => onOpenLocation(selectedImage)}
                  className="absolute top-16 left-4 bg-blue-500 bg-opacity-80 text-white p-2 rounded-full hover:bg-opacity-100 transition-all"
                  title={t('viewer.openFileLocation')}
                >
                  üìÅ
                </button>
                <button
                  onClick={async () => {
                    try {
                      await window.electronAPI.copyImageToClipboard(selectedImage.fullPath)
                      if (showActionFeedback) alert(t('prompts.imageCopiedToClipboard'))
                    } catch (err) { alert(t('prompts.error') + ': ' + err.message) }
                  }}
                  className="absolute top-16 left-16 bg-indigo-500 bg-opacity-80 text-white p-2 rounded-full hover:bg-opacity-100 transition-all"
                  title={t('viewer.copyToClipboard')}
                >
                  üìã
                </button>
                <button
                  onClick={() => onStar(selectedImage)}
                  className="absolute top-28 left-4 bg-yellow-400 bg-opacity-80 text-white p-2 rounded-full hover:bg-opacity-100 transition-all text-lg"
                  title={t('viewer.copyToStarred')}
                >
                  ‚≠ê
                </button>
                <button
                  onClick={() => setSlideshow(s => !s)}
                  className={`absolute top-40 left-4 ${slideshow ? 'bg-green-500' : 'bg-gray-500'} bg-opacity-80 text-white p-2 rounded-full hover:bg-opacity-100 transition-all`}
                  title={t('viewer.slideshow') + ' (Space)'}
                >
                  {slideshow ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è'}
                </button>
                <button
                  onClick={() => setDragMode(d => !d)}
                  className={`absolute top-40 left-16 ${dragMode ? 'bg-cyan-500' : 'bg-gray-500'} bg-opacity-80 text-white p-2 rounded-full hover:bg-opacity-100 transition-all`}
                  title={dragMode ? t('viewer.dragModeOn') : t('viewer.enableDragMode')}
                >
                  ‚úã
                </button>
                <button
                  onClick={() => { setEditMode(editMode === 'crop' ? null : 'crop'); setCropArea(null) }}
                  className={`absolute top-52 left-4 ${editMode === 'crop' ? 'bg-purple-500' : 'bg-gray-500'} bg-opacity-80 text-white p-2 rounded-full hover:bg-opacity-100 transition-all`}
                  title={t('viewer.crop')}
                >
                  ‚úÇÔ∏è
                </button>
                <button
                  onClick={() => { setEditMode(editMode === 'resize' ? null : 'resize'); if (dimensions) { setResizeW(String(dimensions.w)); setResizeH(String(dimensions.h)) } }}
                  className={`absolute top-64 left-4 ${editMode === 'resize' ? 'bg-purple-500' : 'bg-gray-500'} bg-opacity-80 text-white p-2 rounded-full hover:bg-opacity-100 transition-all`}
                  title={t('viewer.resize')}
                >
                  üìê
                </button>
                <button
                  onClick={() => {
                    const newName = prompt(t('prompts.enterNewFilename'), selectedImage.name)
                    if (newName && newName !== selectedImage.name) {
                      window.electronAPI.renameImage(selectedImage.fullPath, newName)
                        .then(result => {
                          alert(t('prompts.fileRenamedSuccess'))
                          onClose()
                        })
                        .catch(err => alert(t('prompts.error') + ': ' + err.message))
                    }
                  }}
                  className="absolute top-[19rem] left-4 bg-gray-500 bg-opacity-80 text-white p-2 rounded-full hover:bg-opacity-100 transition-all"
                  title={t('viewer.rename')}
                >
                  ‚úèÔ∏è
                </button>

                {editMode === 'crop' && cropArea && cropArea.w > 10 && cropArea.h > 10 && (
                  <button
                    onClick={saveCrop}
                    className="absolute top-52 left-16 bg-green-500 text-white px-3 py-1 rounded hover:bg-green-600"
                  >
                    {t('actions.saveCrop')}
                  </button>
                )}

                {editMode === 'resize' && (
                  <div className="absolute top-64 left-16 bg-black bg-opacity-80 p-2 rounded flex items-center gap-2">
                    <input type="number" value={resizeW} onChange={e => setResizeW(e.target.value)} className="w-16 px-1 rounded text-black" placeholder="W" />
                    <span className="text-white">√ó</span>
                    <input type="number" value={resizeH} onChange={e => setResizeH(e.target.value)} className="w-16 px-1 rounded text-black" placeholder="H" />
                    <button onClick={saveResize} className="bg-green-500 text-white px-2 py-1 rounded hover:bg-green-600">{t('actions.save')}</button>
                  </div>
                )}

                <div className="absolute bottom-24 right-4 flex flex-col gap-2">
                  <button
                    onClick={() => setZoom(z => { const nz = Math.min(z * 1.2, 5); zoomRef.current = nz; return nz })}
                    className="bg-black bg-opacity-60 text-white p-2 rounded-full hover:bg-opacity-80 transition-all"
                    title={t('viewer.zoomIn') + ' (+)'}
                  >
                    üîç+
                  </button>
                  <button
                    onClick={() => setZoom(z => { const nz = Math.max(z / 1.2, 0.5); zoomRef.current = nz; return nz })}
                    className="bg-black bg-opacity-60 text-white p-2 rounded-full hover:bg-opacity-80 transition-all"
                    title={t('viewer.zoomOut') + ' (-)'}
                  >
                    üîç-
                  </button>
                  <button
                    onClick={() => { setZoom(1); zoomRef.current = 1; setPosition({ x: 0, y: 0 }); positionRef.current = { x: 0, y: 0 }; setDragMode(false) }}
                    className="bg-black bg-opacity-60 text-white p-2 rounded-full hover:bg-opacity-80 transition-all text-sm"
                    title={t('viewer.resetZoom') + ' (0)'}
                  >
                    1:1
                  </button>
                  {zoom !== 1 && (
                    <div className="bg-black bg-opacity-60 text-white px-2 py-1 rounded text-xs text-center">
                      {Math.round(zoom * 100)}%
                    </div>
                  )}
                </div>

                {currentIndex > 0 && (
                  <button
                    onClick={showPrevious}
                    className="absolute left-4 top-1/2 transform -translate-y-1/2 bg-black bg-opacity-60 text-white p-3 rounded-full hover:bg-opacity-80 transition-all text-2xl"
                    title={t('viewer.previousImage')}
                  >
                    ‚Üê
                  </button>
                )}
                {currentIndex < filteredImages.length - 1 && (
                  <button
                    onClick={showNext}
                    className="absolute right-4 top-1/2 transform -translate-y-1/2 bg-black bg-opacity-60 text-white p-3 rounded-full hover:bg-opacity-80 transition-all text-2xl"
                    title={t('viewer.nextImage')}
                  >
                    ‚Üí
                  </button>
                )}
                <div className="absolute bottom-4 left-4 right-4 bg-black bg-opacity-70 text-white p-4 rounded-lg backdrop-blur-sm">
                  <div className="font-medium text-lg mb-2">
                    {selectedImage.name}
                  </div>
                  <div className="text-gray-300 mb-1">{selectedImage.path}</div>
                  <div className="flex justify-between text-sm text-gray-400 flex-wrap gap-2">
                    <span>{formatFileSize(selectedImage.size)}</span>
                    {dimensions && <span>{dimensions.w} √ó {dimensions.h}</span>}
                    <span>
                      {t('viewer.modified')}:{' '}
                      {new Date(
                        selectedImage.lastModified
                      ).toLocaleDateString()}
                    </span>
                  </div>
                  <div className="text-xs text-gray-500 mt-1">
                    {currentIndex + 1} {t('viewer.of')} {filteredImages.length}
                  </div>
                </div>
              </div>
            </div>
          )
        }
      )

      const createNewTab = (id = Date.now()) => ({
        id,
        selectedDir: '',
        allImages: [],
        displayedImages: [],
        searchTerm: '',
        dirHistory: [],
        historyIndex: -1
      })

      const ImageViewerApp = () => {
        const { t } = useI18n()
        const [tabs, setTabs] = useState(() => {
          const saved = localStorage.getItem('tabs')
          if (saved) {
            try {
              const parsed = JSON.parse(saved)
              if (Array.isArray(parsed) && parsed.length > 0) {
                return parsed.map(t => ({ ...createNewTab(), ...t, allImages: [], displayedImages: [] }))
              }
            } catch (e) {}
          }
          return [createNewTab(1)]
        })
        const [activeTabId, setActiveTabId] = useState(() => {
          const saved = localStorage.getItem('activeTabId')
          return saved ? parseInt(saved) : 1
        })

        const activeTab = tabs.find(t => t.id === activeTabId) || tabs[0]
        const activeTabIndex = tabs.findIndex(t => t.id === activeTabId)

        const updateActiveTab = useCallback((updates) => {
          setTabs(prev => prev.map(t => t.id === activeTabId ? { ...t, ...updates } : t))
        }, [activeTabId])

        const [loading, setLoading] = useState(false)
        const [loadingMore, setLoadingMore] = useState(false)
        const [selectedImage, setSelectedImage] = useState(null)
        const [deleteMode, setDeleteMode] = useState(false)
        const [theme, setTheme] = useState(
          () => localStorage.getItem('theme') || 'midnight'
        )
        const currentTheme = THEMES[theme] || THEMES.midnight
        const [sortBy, setSortBy] = useState(
          () => localStorage.getItem('sortBy') || 'name'
        )
        const [sortOrder, setSortOrder] = useState(
          () => localStorage.getItem('sortOrder') || 'asc'
        )
        const [columnCount, setColumnCount] = useState(
          () => parseInt(localStorage.getItem('columnCount')) || 4
        )
        const [selectedForDeletion, setSelectedForDeletion] = useState(
          new Set()
        )
        const [favoritesDir, setFavoritesDir] = useState('')
        const [isDragOver, setIsDragOver] = useState(false)
        const [showHelp, setShowHelp] = useState(false)
        const [showStarButton, setShowStarButton] = useState(
          () => localStorage.getItem('showStarButton') !== 'false'
        )
        const [keybindings, setKeybindings] = useState(() => {
          const saved = localStorage.getItem('keybindings')
          return saved ? { ...DEFAULT_KEYBINDINGS, ...JSON.parse(saved) } : DEFAULT_KEYBINDINGS
        })
        const [showSettings, setShowSettings] = useState(false)
        const [editingKey, setEditingKey] = useState(null)
        const [clickOutsideToClose, setClickOutsideToClose] = useState(
          () => localStorage.getItem('clickOutsideToClose') !== 'false'
        )
        const [confirmPrompts, setConfirmPrompts] = useState(
          () => localStorage.getItem('confirmPrompts') === 'true'
        )
        const [showActionFeedback, setShowActionFeedback] = useState(
          () => localStorage.getItem('showActionFeedback') === 'true'
        )
        const [maxImageSize, setMaxImageSize] = useState(
          () => parseInt(localStorage.getItem('maxImageSize')) || 90
        )
        const [showHistoryPanel, setShowHistoryPanel] = useState(false)
        const [mainContextMenu, setMainContextMenu] = useState(null)
        const [starVersion, setStarVersion] = useState(0)
        const [recentDirs, setRecentDirs] = useState(() => {
          const saved = localStorage.getItem('recentDirs')
          return saved ? JSON.parse(saved) : []
        })
        const [retainImages, setRetainImages] = useState(
          () => localStorage.getItem('retainImages') === 'true'
        )

        // Derived values from active tab
        const selectedDir = activeTab.selectedDir
        const allImages = activeTab.allImages
        const displayedImages = activeTab.displayedImages
        const searchTerm = activeTab.searchTerm
        const dirHistory = activeTab.dirHistory
        const historyIndex = activeTab.historyIndex

        const scrollContainerRef = useRef(null)
        const loadMoreObserverRef = useRef(null)

        const filteredImages = useMemo(() => {
          let imgs = allImages
          if (searchTerm) {
            imgs = imgs.filter(
              img =>
                img.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                img.path.toLowerCase().includes(searchTerm.toLowerCase()) ||
                img.directory.toLowerCase().includes(searchTerm.toLowerCase())
            )
          }
          const sorted = [...imgs].sort((a, b) => {
            let cmp = 0
            if (sortBy === 'name') cmp = a.name.localeCompare(b.name)
            else if (sortBy === 'date') cmp = b.lastModified - a.lastModified
            else if (sortBy === 'size') cmp = b.size - a.size
            return sortOrder === 'asc' ? cmp : -cmp
          })
          return sorted
        }, [allImages, searchTerm, sortBy, sortOrder])

        const loadedCount = displayedImages.length
        const hasMore = loadedCount < filteredImages.length

        useEffect(() => {
          localStorage.setItem('theme', theme)
        }, [theme])

        useEffect(() => {
          localStorage.setItem('sortBy', sortBy)
        }, [sortBy])

        useEffect(() => {
          localStorage.setItem('sortOrder', sortOrder)
        }, [sortOrder])

        useEffect(() => {
          localStorage.setItem('columnCount', columnCount.toString())
        }, [columnCount])

        useEffect(() => {
          localStorage.setItem('showStarButton', showStarButton.toString())
        }, [showStarButton])

        useEffect(() => {
          localStorage.setItem('keybindings', JSON.stringify(keybindings))
        }, [keybindings])

        useEffect(() => {
          localStorage.setItem('clickOutsideToClose', clickOutsideToClose.toString())
        }, [clickOutsideToClose])

        useEffect(() => {
          localStorage.setItem('confirmPrompts', confirmPrompts.toString())
        }, [confirmPrompts])

        useEffect(() => {
          localStorage.setItem('showActionFeedback', showActionFeedback.toString())
        }, [showActionFeedback])

        useEffect(() => {
          localStorage.setItem('maxImageSize', maxImageSize.toString())
        }, [maxImageSize])

        useEffect(() => {
          localStorage.setItem('recentDirs', JSON.stringify(recentDirs))
        }, [recentDirs])

        useEffect(() => {
          localStorage.setItem('retainImages', retainImages.toString())
        }, [retainImages])

        useEffect(() => {
          // Save tabs (without images to avoid huge localStorage)
          const tabsToSave = tabs.map(t => ({
            id: t.id,
            selectedDir: t.selectedDir,
            searchTerm: t.searchTerm,
            dirHistory: t.dirHistory,
            historyIndex: t.historyIndex
          }))
          localStorage.setItem('tabs', JSON.stringify(tabsToSave))
        }, [tabs])

        useEffect(() => {
          localStorage.setItem('activeTabId', activeTabId.toString())
        }, [activeTabId])

        useEffect(() => {
          const fetchFavoritesDir = async () => {
            const dir = await window.electronAPI.getFavoritesDir()
            setFavoritesDir(dir)
          }
          fetchFavoritesDir()
        }, [])

        // Reload images when switching tabs if the tab has a directory but no images
        useEffect(() => {
          if (activeTab.selectedDir && activeTab.allImages.length === 0) {
            loadDir(activeTab.selectedDir, false)
          }
        }, [activeTabId])

        const loadDir = useCallback(async (dirPath, addToHistory = true) => {
          if (!dirPath) return
          try {
            setLoading(true)
            setSelectedForDeletion(new Set())
            setDeleteMode(false)
            const images = await window.electronAPI.getImages(dirPath)
            if (addToHistory) {
              updateActiveTab({
                selectedDir: dirPath,
                allImages: images,
                searchTerm: '',
                dirHistory: [...dirHistory.slice(0, historyIndex + 1), dirPath],
                historyIndex: historyIndex + 1
              })
              // Add to persistent recent dirs (keep last 20, no duplicates)
              setRecentDirs(prev => {
                const filtered = prev.filter(d => d !== dirPath)
                return [dirPath, ...filtered].slice(0, 20)
              })
            } else {
              updateActiveTab({
                selectedDir: dirPath,
                allImages: images,
                searchTerm: ''
              })
            }
          } catch (error) {
            console.error('Error loading directory:', error)
            alert(t('prompts.errorLoading') + ': ' + error.message)
          } finally {
            setLoading(false)
          }
        }, [historyIndex, dirHistory, updateActiveTab])

        const handleDirSelect = useCallback(async () => {
          const dirPath = await window.electronAPI.selectDirectory()
          if (dirPath) loadDir(dirPath)
        }, [loadDir])

        const goBack = useCallback(() => {
          if (historyIndex > 0) {
            const newIndex = historyIndex - 1
            updateActiveTab({ historyIndex: newIndex })
            loadDir(dirHistory[newIndex], false)
          }
        }, [historyIndex, dirHistory, loadDir, updateActiveTab])

        const goForward = useCallback(() => {
          if (historyIndex < dirHistory.length - 1) {
            const newIndex = historyIndex + 1
            updateActiveTab({ historyIndex: newIndex })
            loadDir(dirHistory[newIndex], false)
          }
        }, [historyIndex, dirHistory, loadDir, updateActiveTab])

        useEffect(() => {
          const handleMouseButton = e => {
            if (selectedImage) return
            if (e.button === 3) { e.preventDefault(); goBack() }
            else if (e.button === 4) { e.preventDefault(); goForward() }
          }
          window.addEventListener('mouseup', handleMouseButton)
          return () => window.removeEventListener('mouseup', handleMouseButton)
        }, [goBack, goForward, selectedImage])

        // Global keyboard shortcuts for main window
        useEffect(() => {
          const handleGlobalKeyPress = e => {
            // Don't trigger if modal is open or typing in input
            if (selectedImage || e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return

            const key = e.key
            if ((e.ctrlKey || e.metaKey) && key === keybindings.openDirectory) { e.preventDefault(); handleDirSelect() }
            else if ((e.ctrlKey || e.metaKey) && key === keybindings.newTab) {
              e.preventDefault()
              const newTab = createNewTab()
              setTabs(prev => [...prev, newTab])
              setActiveTabId(newTab.id)
            }
            else if ((e.ctrlKey || e.metaKey) && key === keybindings.closeTab) {
              e.preventDefault()
              if (tabs.length > 1) {
                const newTabs = tabs.filter(t => t.id !== activeTabId)
                setTabs(newTabs)
                setActiveTabId(newTabs[0].id)
              }
            }
            else if (key === keybindings.viewFavorites || key === 'F') { viewFavorites() }
            else if (key === keybindings.toggleDeleteMode) { setDeleteMode(d => !d) }
            else if (key === keybindings.toggleDarkMode || key === 'M') { setDarkMode(d => !d) }
            else if (key === keybindings.openSettings) { setShowSettings(true) }
            else if (key === keybindings.openHelp) { setShowHelp(true) }
            else if (key === keybindings.toggleHistoryPanel || key === 'H') { setShowHistoryPanel(v => !v) }
          }
          document.addEventListener('keydown', handleGlobalKeyPress)
          return () => document.removeEventListener('keydown', handleGlobalKeyPress)
        }, [selectedImage, keybindings, handleDirSelect, viewFavorites, tabs, activeTabId])

        useEffect(() => {
          setTabs(prev => prev.map(t => t.id === activeTabId ? { ...t, displayedImages: filteredImages.slice(0, BATCH_SIZE) } : t))
          if (scrollContainerRef.current) {
            scrollContainerRef.current.scrollTop = 0
          }
        }, [filteredImages, activeTabId])

        const loadMoreImages = useCallback(() => {
          if (loadingMore || !hasMore) return
          setLoadingMore(true)
          setTimeout(() => {
            const nextBatch = filteredImages.slice(
              loadedCount,
              loadedCount + BATCH_SIZE
            )
            setTabs(prev => prev.map(t => t.id === activeTabId ? { ...t, displayedImages: [...t.displayedImages, ...nextBatch] } : t))
            setLoadingMore(false)
          }, 300)
        }, [filteredImages, loadedCount, loadingMore, hasMore, activeTabId])

        useEffect(() => {
          const scrollContainer = scrollContainerRef.current
          if (!scrollContainer || !hasMore) return

          // IntersectionObserver for infinite scroll
          const observer = new IntersectionObserver(
            entries => {
              const [entry] = entries
              if (entry.isIntersecting && !loadingMore) {
                loadMoreImages()
              }
            },
            { root: scrollContainer, rootMargin: '600px', threshold: 0.1 }
          )

          const observerTarget = loadMoreObserverRef.current
          if (observerTarget) {
            observer.observe(observerTarget)
          }

          // Fallback scroll handler for cases where IntersectionObserver doesn't trigger
          const handleScroll = () => {
            if (loadingMore || !hasMore) return
            const { scrollTop, scrollHeight, clientHeight } = scrollContainer
            if (scrollTop + clientHeight >= scrollHeight - 800) {
              loadMoreImages()
            }
          }

          scrollContainer.addEventListener('scroll', handleScroll, { passive: true })

          return () => {
            if (observerTarget) {
              observer.unobserve(observerTarget)
            }
            scrollContainer.removeEventListener('scroll', handleScroll)
          }
        }, [loadMoreImages, hasMore, loadingMore, selectedDir, displayedImages.length])

        const handleBatchDelete = useCallback(
          async pathsToDelete => {
            const numToDelete = pathsToDelete.length
            if (numToDelete === 0) return
            if (confirmPrompts) {
              const confirmMessage = t('deleteMode.confirmDelete', { count: numToDelete })
              if (!confirm(confirmMessage)) return
            }

            try {
              await window.electronAPI.deleteImage(pathsToDelete)
              const deletedPathsSet = new Set(pathsToDelete)

              updateActiveTab({
                allImages: allImages.filter(img => !deletedPathsSet.has(img.fullPath)),
                displayedImages: displayedImages.filter(img => !deletedPathsSet.has(img.fullPath))
              })

              if (selectedForDeletion.size > 0)
                setSelectedForDeletion(new Set())
              if (selectedImage && deletedPathsSet.has(selectedImage.fullPath))
                setSelectedImage(null)
            } catch (error) {
              console.error('Error deleting image(s):', error)
              alert(t('prompts.errorDeleting') + ': ' + error.message)
            }
          },
          [selectedImage, selectedForDeletion, confirmPrompts, allImages, displayedImages, updateActiveTab, t]
        )

        const handleStarImage = useCallback(async image => {
          try {
            const result = await window.electronAPI.starImage(image.fullPath)
            if (result.exists) {
              if (!confirmPrompts || confirm(t('star.alreadyStarred'))) {
                await window.electronAPI.unstarImage(result.starredPath)
              }
            }
            setStarVersion(v => v + 1)
          } catch (error) {
            console.error('Failed to star image:', error)
            alert(t('prompts.error') + ': ' + error.message)
          }
        }, [confirmPrompts, t])

        const viewFavorites = useCallback(async () => {
          if (!favoritesDir || loading) return
          loadDir(favoritesDir)
        }, [favoritesDir, loading, loadDir])

        const handleToggleDeleteMode = () => {
          setDeleteMode(prev => {
            if (prev) {
              setSelectedForDeletion(new Set())
            }
            return !prev
          })
        }
        const handleToggleImageSelection = useCallback(image => {
          setSelectedForDeletion(prevSet => {
            const newSet = new Set(prevSet)
            if (newSet.has(image.fullPath)) {
              newSet.delete(image.fullPath)
            } else {
              newSet.add(image.fullPath)
            }
            return newSet
          })
        }, [])
        const isSelectedForDeletion = useCallback(
          image => selectedForDeletion.has(image.fullPath),
          [selectedForDeletion]
        )
        const openFileLocation = useCallback(async image => {
          try {
            await window.electronAPI.openFileLocation(image.fullPath)
          } catch (error) {
            console.error('Error opening file location:', error)
            alert(t('prompts.errorOpeningLocation') + ': ' + error.message)
          }
        }, [t])
        const handleImageClick = useCallback(
          image => setSelectedImage(image),
          []
        )
        const handleModalClose = useCallback(() => setSelectedImage(null), [])

        const handleMainContextMenu = useCallback((e, image) => {
          setMainContextMenu({ x: e.clientX, y: e.clientY, image })
        }, [])

        const closeMainContextMenu = useCallback(() => setMainContextMenu(null), [])

        const handleDrop = useCallback(async e => {
          e.preventDefault()
          setIsDragOver(false)
          const items = e.dataTransfer.items
          for (const item of items) {
            if (item.kind === 'file') {
              const entry = item.webkitGetAsEntry?.()
              if (entry?.isDirectory) {
                const dirPath = e.dataTransfer.files[0]?.path
                if (dirPath) loadDir(dirPath)
                break
              }
            }
          }
        }, [loadDir])

        const handleDragOver = useCallback(e => {
          e.preventDefault()
          setIsDragOver(true)
        }, [])

        const handleDragLeave = useCallback(e => {
          e.preventDefault()
          setIsDragOver(false)
        }, [])

        return (
          <div
            ref={scrollContainerRef}
            className={`app-container transition-colors duration-300 ${currentTheme.bg} ${currentTheme.text} ${isDragOver ? 'ring-4 ring-inset ring-blue-500' : ''}`}
            onDrop={handleDrop}
            onDragOver={handleDragOver}
            onDragLeave={handleDragLeave}
          >
            <header
              className={`sticky top-0 z-40 border-b backdrop-blur-sm transition-colors ${currentTheme.header} ${currentTheme.border}`}
            >
              {/* Tab Bar */}
              <div className={`flex items-center gap-1 px-2 pt-2 border-b ${currentTheme.border}`}>
                {tabs.map(tab => (
                  <div
                    key={tab.id}
                    className={`group flex items-center gap-1 px-3 py-1.5 rounded-t-lg cursor-pointer transition-colors ${
                      tab.id === activeTabId
                        ? `${currentTheme.bg} ${currentTheme.text}`
                        : `${currentTheme.button} ${currentTheme.textSecondary}`
                    }`}
                    onClick={() => setActiveTabId(tab.id)}
                  >
                    <span className="text-sm truncate max-w-[120px]">
                      {tab.selectedDir ? tab.selectedDir.split(/[\\/]/).pop() : t('navigation.newTab')}
                    </span>
                    {tabs.length > 1 && (
                      <button
                        onClick={e => {
                          e.stopPropagation()
                          const newTabs = tabs.filter(t => t.id !== tab.id)
                          setTabs(newTabs)
                          if (tab.id === activeTabId) {
                            setActiveTabId(newTabs[0].id)
                          }
                        }}
                        className="opacity-0 group-hover:opacity-100 ml-1 text-gray-500 hover:text-red-500 transition-opacity"
                      >
                        ‚úï
                      </button>
                    )}
                  </div>
                ))}
                <button
                  onClick={() => {
                    const newTab = createNewTab()
                    setTabs(prev => [...prev, newTab])
                    setActiveTabId(newTab.id)
                  }}
                  className={`p-1.5 rounded-lg transition-colors ${currentTheme.button} ${currentTheme.textSecondary}`}
                  title={t('navigation.newTab')}
                >
                  +
                </button>
              </div>
              <div className="max-w-7xl mx-auto px-4 py-4">
                <div className="flex items-center justify-between gap-4 flex-wrap">
                  <h1 className={`text-2xl font-bold bg-gradient-to-r ${currentTheme.gradient} bg-clip-text text-transparent`}>
                    {t('app.title')}
                  </h1>
                  <div className="flex items-center gap-2 flex-wrap">
                    <button
                      onClick={goBack}
                      disabled={historyIndex <= 0}
                      className={`p-2 rounded-lg transition-all ${currentTheme.button} disabled:opacity-40`}
                      title={t('navigation.back')}
                    >
                      ‚óÄ
                    </button>
                    <button
                      onClick={goForward}
                      disabled={historyIndex >= dirHistory.length - 1}
                      className={`p-2 rounded-lg transition-all ${currentTheme.button} disabled:opacity-40`}
                      title={t('navigation.forward')}
                    >
                      ‚ñ∂
                    </button>
                    <button
                      onClick={() => setShowHistoryPanel(v => !v)}
                      className={`p-2 rounded-lg transition-all ${showHistoryPanel ? currentTheme.accent + ' text-white' : currentTheme.button}`}
                      title={t('navigation.historyAndRecent')}
                    >
                      üìú
                    </button>
                    <button
                      onClick={handleDirSelect}
                      disabled={loading}
                      className={`flex items-center gap-2 px-4 py-2 rounded-lg transition-all font-medium ${currentTheme.accent} text-white disabled:opacity-40`}
                    >
                      üìÅ{' '}
                      {loading
                        ? t('app.scanning')
                        : selectedDir
                        ? window.path.basename(selectedDir)
                        : t('actions.selectDirectory')}
                    </button>
                    <button
                      onClick={viewFavorites}
                      disabled={!favoritesDir || loading}
                      title={t('star.viewStarred')}
                      className="flex items-center gap-2 px-4 py-2 rounded-lg transition-all font-medium bg-amber-500 hover:bg-amber-600 text-white disabled:opacity-40"
                    >
                      ‚≠ê
                    </button>
                    {allImages.length > 0 && (
                      <button
                        onClick={handleToggleDeleteMode}
                        className={`flex items-center gap-2 px-4 py-2 rounded-lg transition-all font-medium ${
                          deleteMode ? 'bg-red-600 hover:bg-red-700 text-white' : currentTheme.button
                        }`}
                      >
                        üóëÔ∏è {deleteMode ? t('actions.cancel') : t('deleteMode.selectToDelete')}
                      </button>
                    )}
                    <button
                      onClick={() => setShowHelp(true)}
                      className={`p-2 rounded-lg transition-all ${currentTheme.button}`}
                      title={t('help.title')}
                    >
                      ‚ùì
                    </button>
                    <button
                      onClick={() => setShowSettings(true)}
                      className={`p-2 rounded-lg transition-all ${currentTheme.button}`}
                      title={t('settings.title')}
                    >
                      ‚öôÔ∏è
                    </button>
                  </div>
                </div>
                {allImages.length > 0 && (
                  <div className="mt-4 flex items-center justify-between gap-4 flex-wrap">
                    <div className="flex-1 max-w-md">
                      <div className="relative">
                        <span className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-500">
                          üîç
                        </span>
                        <input
                          type="text"
                          placeholder={t('images.searchPlaceholder')}
                          value={searchTerm}
                          onChange={e => updateActiveTab({ searchTerm: e.target.value })}
                          className={`w-full pl-10 pr-4 py-2 rounded-lg border transition-colors ${currentTheme.input} focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50`}
                        />
                      </div>
                    </div>
                    <div className="flex items-center gap-2">
                      <div className={`flex items-center rounded-lg border overflow-hidden ${currentTheme.border}`}>
                        <select
                          value={sortBy}
                          onChange={e => setSortBy(e.target.value)}
                          className={`px-3 py-2 border-none transition-colors ${currentTheme.bgSecondary} ${currentTheme.text}`}
                        >
                          <option value="name">{t('sort.name')}</option>
                          <option value="date">{t('sort.date')}</option>
                          <option value="size">{t('sort.size')}</option>
                        </select>
                        <button
                          onClick={() => setSortOrder(o => o === 'asc' ? 'desc' : 'asc')}
                          className={`px-3 py-2 border-l transition-colors ${currentTheme.bgSecondary} ${currentTheme.border} ${currentTheme.text}`}
                          title={sortOrder === 'asc' ? t('sort.ascending') : t('sort.descending')}
                        >
                          {sortBy === 'name'
                            ? (sortOrder === 'asc' ? 'A‚ÜíZ' : 'Z‚ÜíA')
                            : sortBy === 'date'
                            ? (sortOrder === 'asc' ? 'üïê‚Üì' : 'üïê‚Üë')
                            : (sortOrder === 'asc' ? 'L‚ÜíS' : 'S‚ÜíL')}
                        </button>
                      </div>
                      <div className={`flex items-center gap-1 px-2 py-1 rounded-lg border ${currentTheme.border}`}>
                        <button
                          onClick={() => setColumnCount(c => Math.max(2, c - 1))}
                          className={`px-2 py-1 rounded ${currentTheme.button}`}
                          disabled={columnCount <= 2}
                        >-</button>
                        <span className="px-2 text-sm">{columnCount} {t('sort.columns')}</span>
                        <button
                          onClick={() => setColumnCount(c => Math.min(8, c + 1))}
                          className={`px-2 py-1 rounded ${currentTheme.button}`}
                          disabled={columnCount >= 8}
                        >+</button>
                      </div>
                      <button
                        onClick={() => setShowStarButton(s => !s)}
                        className={`px-2 py-2 rounded-lg border transition-colors ${
                          showStarButton ? 'bg-amber-500 border-amber-500 text-white' : `${currentTheme.bgSecondary} ${currentTheme.border} ${currentTheme.textSecondary}`
                        }`}
                        title={showStarButton ? t('star.hideQuickStar') : t('star.showQuickStar')}
                      >
                        ‚≠ê
                      </button>
                    </div>
                    <div className={`text-sm ${currentTheme.textSecondary} whitespace-nowrap`}>{t('images.showingOf', { shown: displayedImages.length, total: filteredImages.length })}</div>
                  </div>
                )}
              </div>
            </header>
            {showHistoryPanel && (
              <div className="fixed inset-0 z-50" onClick={() => setShowHistoryPanel(false)}>
                <div
                  className={`absolute top-20 left-4 right-4 max-w-2xl mx-auto backdrop-blur-xl rounded-xl shadow-2xl border ${currentTheme.bgSecondary} ${currentTheme.border}`}
                  onClick={e => e.stopPropagation()}
                >
                  <div className="p-4">
                    <div className="flex items-center justify-between mb-3">
                      <span className="text-lg font-semibold">{t('navigation.historyAndRecent')}</span>
                      <button
                        onClick={() => setShowHistoryPanel(false)}
                        className={`${currentTheme.textSecondary} hover:opacity-70 p-1`}
                      >
                        ‚úï
                      </button>
                    </div>

                    {dirHistory.length > 0 && (
                      <div className="mb-4">
                        <div className="flex items-center justify-between mb-2">
                          <span className={`text-sm font-medium ${currentTheme.textSecondary}`}>{t('navigation.sessionHistory')} ({dirHistory.length})</span>
                          <button
                            onClick={() => updateActiveTab({ dirHistory: [], historyIndex: -1 })}
                            className={`text-xs px-2 py-0.5 rounded ${currentTheme.button} hover:text-red-400`}
                            title={t('actions.clearAll')}
                          >
                            {t('actions.clearAll')}
                          </button>
                        </div>
                        <div className="flex flex-wrap gap-2 max-h-24 overflow-y-auto">
                          {dirHistory.map((dir, idx) => (
                            <div key={idx} className="group relative">
                              <button
                                onClick={() => {
                                  updateActiveTab({ historyIndex: idx })
                                  loadDir(dir, false)
                                  setShowHistoryPanel(false)
                                }}
                                className={`px-3 py-1 pr-6 rounded text-sm truncate max-w-xs transition-colors ${
                                  idx === historyIndex
                                    ? `${currentTheme.accent} text-white`
                                    : currentTheme.button
                                }`}
                                title={dir}
                              >
                                {dir.split(/[\\/]/).pop() || dir}
                              </button>
                              <button
                                onClick={e => {
                                  e.stopPropagation()
                                  const newHistory = dirHistory.filter((_, i) => i !== idx)
                                  const newIndex = idx < historyIndex ? historyIndex - 1 : (idx === historyIndex ? Math.min(historyIndex, newHistory.length - 1) : historyIndex)
                                  updateActiveTab({ dirHistory: newHistory, historyIndex: Math.max(-1, newIndex) })
                                }}
                                className="absolute right-1 top-1/2 -translate-y-1/2 opacity-0 group-hover:opacity-100 text-xs hover:text-red-400 transition-opacity"
                                title={t('actions.remove')}
                              >
                                ‚úï
                              </button>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}

                    {recentDirs.length > 0 && (
                      <div>
                        <div className="flex items-center justify-between mb-2">
                          <span className={`text-sm font-medium ${currentTheme.textSecondary}`}>{t('navigation.recentlyAccessed')}</span>
                          <button
                            onClick={() => setRecentDirs([])}
                            className={`text-xs px-2 py-0.5 rounded ${currentTheme.button} hover:text-red-400`}
                            title={t('actions.clearAll')}
                          >
                            {t('actions.clearAll')}
                          </button>
                        </div>
                        <div className="flex flex-wrap gap-2 max-h-32 overflow-y-auto">
                          {recentDirs.map((dir, idx) => (
                            <div key={idx} className="group relative">
                              <button
                                onClick={() => {
                                  loadDir(dir)
                                  setShowHistoryPanel(false)
                                }}
                                className={`px-3 py-1 pr-6 rounded text-sm truncate max-w-xs transition-colors ${
                                  dir === selectedDir
                                    ? 'bg-emerald-500 text-white'
                                    : currentTheme.button
                                }`}
                                title={dir}
                              >
                                {dir.split(/[\\/]/).pop() || dir}
                              </button>
                              <button
                                onClick={e => {
                                  e.stopPropagation()
                                  setRecentDirs(prev => prev.filter((_, i) => i !== idx))
                                }}
                                className="absolute right-1 top-1/2 -translate-y-1/2 opacity-0 group-hover:opacity-100 text-xs hover:text-red-400 transition-opacity"
                                title={t('actions.remove')}
                              >
                                ‚úï
                              </button>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}

                    {dirHistory.length === 0 && recentDirs.length === 0 && (
                      <div className={`text-center ${currentTheme.textSecondary} py-4`}>
                        {t('navigation.noHistoryYet')}
                      </div>
                    )}
                  </div>
                </div>
              </div>
            )}
            <main>
              {loading ? (
                <div className="flex flex-col items-center justify-center py-20">
                  <div className={`animate-spin rounded-full h-16 w-16 border-b-4 ${currentTheme.accentText.replace('text-', 'border-')} mb-4`}></div>
                  <p className="text-lg font-medium">{t('app.scanningDirectory')}</p>
                </div>
              ) : allImages.length === 0 ? (
                <div className="flex flex-col items-center justify-center py-20 text-center">
                  <div className="text-8xl mb-6">üñºÔ∏è</div>
                  <h2 className="text-2xl font-medium mb-3">{t('images.noImagesFound')}</h2>
                  <p className={`${currentTheme.textSecondary} mb-8 max-w-md`}>
                    {t('images.selectDirectoryToStart')}
                  </p>
                  <button
                    onClick={handleDirSelect}
                    className={`flex items-center gap-2 px-6 py-3 ${currentTheme.accent} text-white rounded-lg transition-colors font-medium`}
                  >
                    üìÅ {t('actions.selectDirectory')}
                  </button>
                </div>
              ) : displayedImages.length === 0 ? (
                <div className="flex flex-col items-center justify-center py-20 text-center">
                  <div className="text-8xl mb-6">üîç</div>
                  <h2 className="text-2xl font-medium mb-3">
                    {t('images.noMatchesFound')}
                  </h2>
                  <p className={currentTheme.textSecondary}>
                    {t('images.tryAdjustingSearch')}
                  </p>
                </div>
              ) : (
                <WaterfallGrid
                  displayedImages={displayedImages}
                  onImageClick={handleImageClick}
                  onToggleSelection={handleToggleImageSelection}
                  onStar={handleStarImage}
                  deleteMode={deleteMode}
                  theme={currentTheme}
                  isSelected={isSelectedForDeletion}
                  loadMoreObserverRef={loadMoreObserverRef}
                  loadingMore={loadingMore}
                  hasMore={hasMore}
                  filteredImagesCount={filteredImages.length}
                  columnCount={columnCount}
                  showStarButton={showStarButton}
                  onContextMenu={handleMainContextMenu}
                  starVersion={starVersion}
                  retainImages={retainImages}
                />
              )}
            </main>
            <ImageModal
              selectedImage={selectedImage}
              filteredImages={filteredImages}
              onClose={handleModalClose}
              onDelete={handleBatchDelete}
              onOpenLocation={openFileLocation}
              onNavigate={setSelectedImage}
              onStar={handleStarImage}
              keybindings={keybindings}
              clickOutsideToClose={clickOutsideToClose}
              showActionFeedback={showActionFeedback}
              maxImageSize={maxImageSize}
            />
            {deleteMode && selectedForDeletion.size > 0 && (
              <div className="fixed bottom-0 left-0 right-0 z-50 bg-gray-800/90 backdrop-blur-sm p-4 border-t border-gray-700">
                <div className="max-w-7xl mx-auto flex justify-between items-center">
                  <span className="text-white font-medium">
                    {t('images.imagesSelected', { count: selectedForDeletion.size })}
                  </span>
                  <button
                    onClick={() =>
                      handleBatchDelete(Array.from(selectedForDeletion))
                    }
                    className="px-6 py-2 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700 transition-colors"
                  >
                    {t('actions.deleteSelected')}
                  </button>
                </div>
              </div>
            )}
            {mainContextMenu && (
              <div
                className="fixed inset-0 z-50"
                onClick={closeMainContextMenu}
              >
                <div
                  className="fixed backdrop-blur-xl bg-black/60 border border-white/20 rounded-xl shadow-2xl py-2 z-[60] min-w-[180px]"
                  style={{ left: mainContextMenu.x, top: mainContextMenu.y }}
                  onClick={e => e.stopPropagation()}
                >
                  <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => { setSelectedImage(mainContextMenu.image); closeMainContextMenu() }}>{t('contextMenu.viewImage')}</button>
                  <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => { openFileLocation(mainContextMenu.image); closeMainContextMenu() }}>{t('contextMenu.openLocation')}</button>
                  <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={async () => { await window.electronAPI.copyImageToClipboard(mainContextMenu.image.fullPath); if (showActionFeedback) alert(t('prompts.copied')); closeMainContextMenu() }}>{t('viewer.copyToClipboard')}</button>
                  <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => { handleStarImage(mainContextMenu.image); closeMainContextMenu() }}>{t('star.starUnstar')}</button>
                  <div className="border-t border-white/20 my-1"></div>
                  <button className="w-full px-4 py-2 text-left text-white hover:bg-white/10 text-sm transition-colors" onClick={() => { handleBatchDelete([mainContextMenu.image.fullPath]); closeMainContextMenu() }}>{t('actions.delete')}</button>
                </div>
              </div>
            )}
            {showHelp && (
              <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50" onClick={() => setShowHelp(false)}>
                <div className={`p-6 rounded-xl max-w-2xl max-h-[80vh] overflow-y-auto ${darkMode ? 'bg-gray-800 text-white' : 'bg-white text-gray-900'}`} onClick={e => e.stopPropagation()}>
                  <h2 className="text-xl font-bold mb-4">{t('help.title')}</h2>

                  <h3 className="text-md font-semibold mb-2 text-blue-400">{t('help.imageViewer')}</h3>
                  <div className="grid grid-cols-2 gap-2 text-sm mb-4">
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.prevImage)}</kbd> / <kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.nextImage)}</kbd> {t('help.navigate')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.zoomIn)}</kbd> / <kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.zoomOut)}</kbd> {t('help.zoom')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.resetZoom)}</kbd> {t('viewer.resetZoom')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.toggleDragMode)}</kbd> {t(KEYBINDING_LABELS.toggleDragMode)}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.toggleSlideshow)}</kbd> {t('viewer.slideshow')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.closeModal)}</kbd> {t('actions.close')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.deleteImage)}</kbd> {t('actions.delete')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.starImage)}</kbd> {t('star.starUnstar')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.copyToClipboard)}</kbd> {t('viewer.copyToClipboard')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.openLocation)}</kbd> {t('viewer.openFileLocation')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.cropImage)}</kbd> {t('viewer.crop')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.resizeImage)}</kbd> {t('viewer.resize')}</p>
                  </div>

                  <h3 className="text-md font-semibold mb-2 text-green-400">{t('help.mainWindow')}</h3>
                  <div className="grid grid-cols-2 gap-2 text-sm mb-4">
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">Ctrl+{formatKey(keybindings.openDirectory)}</kbd> {t('help.openDirectory')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">Ctrl+{formatKey(keybindings.newTab)}</kbd> {t('navigation.newTab')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">Ctrl+{formatKey(keybindings.closeTab)}</kbd> {t('navigation.closeTab')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.viewFavorites)}</kbd> {t('star.viewStarred')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.toggleDeleteMode)}</kbd> {t('deleteMode.selectToDelete')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.toggleDarkMode)}</kbd> {t('darkMode.toggle')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.toggleHistoryPanel)}</kbd> {t('navigation.historyAndRecent')}</p>
                    <p><kbd className="px-2 py-1 bg-gray-600 rounded text-white">{formatKey(keybindings.openSettings)}</kbd> {t('settings.title')}</p>
                  </div>

                  <h3 className="text-md font-semibold mb-2 text-yellow-400">{t('help.other')}</h3>
                  <ul className="text-sm space-y-1 list-disc list-inside">
                    <li>{t('help.dragDropFolders')}</li>
                    <li>{t('help.scrollWheelZoom')}</li>
                    <li>{t('help.mouseBackForward')}</li>
                    <li>{t('help.rightClickMenu')}</li>
                  </ul>
                  <button onClick={() => setShowHelp(false)} className="mt-4 w-full py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600">{t('actions.close')}</button>
                </div>
              </div>
            )}
            {showSettings && (
              <SettingsModal
                theme={theme}
                currentTheme={currentTheme}
                setTheme={setTheme}
                showSettings={showSettings}
                setShowSettings={setShowSettings}
                clickOutsideToClose={clickOutsideToClose}
                setClickOutsideToClose={setClickOutsideToClose}
                confirmPrompts={confirmPrompts}
                setConfirmPrompts={setConfirmPrompts}
                showActionFeedback={showActionFeedback}
                setShowActionFeedback={setShowActionFeedback}
                maxImageSize={maxImageSize}
                setMaxImageSize={setMaxImageSize}
                keybindings={keybindings}
                setKeybindings={setKeybindings}
                editingKey={editingKey}
                setEditingKey={setEditingKey}
                retainImages={retainImages}
                setRetainImages={setRetainImages}
              />
            )}
          </div>
        )
      }

      const SettingsModal = ({
        theme,
        currentTheme,
        setTheme,
        showSettings,
        setShowSettings,
        clickOutsideToClose,
        setClickOutsideToClose,
        confirmPrompts,
        setConfirmPrompts,
        showActionFeedback,
        setShowActionFeedback,
        maxImageSize,
        setMaxImageSize,
        keybindings,
        setKeybindings,
        editingKey,
        setEditingKey,
        retainImages,
        setRetainImages
      }) => {
        const { t, locale, setLocale, availableLocales } = useI18n()
        return (
          <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50" onClick={() => { setShowSettings(false); setEditingKey(null) }}>
            <div className={`p-6 rounded-xl max-w-lg w-full mx-4 max-h-[90vh] overflow-y-auto ${currentTheme.bgSecondary} ${currentTheme.text}`} onClick={e => e.stopPropagation()}>
              <h2 className="text-xl font-bold mb-4">{t('settings.title')}</h2>

              <h3 className="text-lg font-semibold mb-3">{t('settings.appearance')}</h3>
              <div className={`mb-4 p-3 rounded-lg ${currentTheme.bg}`}>
                <div className="grid grid-cols-4 gap-2">
                  {Object.entries(THEMES).map(([key, th]) => (
                    <button
                      key={key}
                      onClick={() => setTheme(key)}
                      className={`p-2 rounded-lg text-xs font-medium transition-all ${
                        theme === key ? 'ring-2 ring-offset-2 ring-blue-500' : ''
                      } ${th.bg} ${th.text}`}
                      title={th.name}
                    >
                      <div className={`h-4 w-full rounded mb-1 bg-gradient-to-r ${th.gradient}`}></div>
                      {th.name}
                    </button>
                  ))}
                </div>
              </div>

              <h3 className="text-lg font-semibold mb-3">{t('settings.behavior')}</h3>
              <div className={`flex items-center justify-between py-2 border-b ${currentTheme.border}`}>
                <span>{t('settings.language')}</span>
                <select
                  value={locale}
                  onChange={e => setLocale(e.target.value)}
                  className={`px-3 py-1 rounded ${currentTheme.button}`}
                >
                  {availableLocales.map(loc => (
                    <option key={loc} value={loc}>{LOCALE_NAMES[loc] || loc}</option>
                  ))}
                </select>
              </div>
              <div className={`flex items-center justify-between py-2 border-b ${currentTheme.border}`}>
                <span>{t('settings.clickOutsideToClose')}</span>
                <button
                  onClick={() => setClickOutsideToClose(v => !v)}
                  className={`px-3 py-1 rounded ${clickOutsideToClose ? 'bg-emerald-500 text-white' : currentTheme.button}`}
                >
                  {clickOutsideToClose ? t('settings.on') : t('settings.off')}
                </button>
              </div>
              <div className={`flex items-center justify-between py-2 border-b ${currentTheme.border}`}>
                <span>{t('settings.confirmationPrompts')}</span>
                <button
                  onClick={() => setConfirmPrompts(v => !v)}
                  className={`px-3 py-1 rounded ${confirmPrompts ? 'bg-emerald-500 text-white' : currentTheme.button}`}
                >
                  {confirmPrompts ? t('settings.on') : t('settings.off')}
                </button>
              </div>
              <div className={`flex items-center justify-between py-2 border-b ${currentTheme.border}`}>
                <span>{t('settings.showActionFeedback')}</span>
                <button
                  onClick={() => setShowActionFeedback(v => !v)}
                  className={`px-3 py-1 rounded ${showActionFeedback ? 'bg-emerald-500 text-white' : currentTheme.button}`}
                >
                  {showActionFeedback ? t('settings.on') : t('settings.off')}
                </button>
              </div>
              <div className={`flex items-center justify-between py-2 border-b ${currentTheme.border}`}>
                <span>{t('settings.maxImageSize')}</span>
                <div className="flex items-center gap-2">
                  <input
                    type="range"
                    min="50"
                    max="100"
                    value={maxImageSize}
                    onChange={e => setMaxImageSize(parseInt(e.target.value))}
                    className="w-24"
                  />
                  <span className="w-10 text-right">{maxImageSize}%</span>
                </div>
              </div>
              <div className={`flex items-center justify-between py-2 mb-4 border-b ${currentTheme.border}`}>
                <span>{t('settings.retainImages')}</span>
                <button
                  onClick={() => setRetainImages(v => !v)}
                  className={`px-3 py-1 rounded ${retainImages ? 'bg-emerald-500 text-white' : currentTheme.button}`}
                >
                  {retainImages ? t('settings.on') : t('settings.off')}
                </button>
              </div>

              <h3 className="text-lg font-semibold mb-3">{t('settings.keybindings')}</h3>
              <div className="space-y-2 max-h-48 overflow-y-auto">
                {Object.keys(keybindings).map(action => (
                  <div key={action} className={`flex items-center justify-between py-2 border-b ${currentTheme.border}`}>
                    <span>{t(KEYBINDING_LABELS[action])}</span>
                    <button
                      onClick={() => setEditingKey(action)}
                      className={`px-3 py-1 rounded ${editingKey === action ? 'bg-blue-500 text-white animate-pulse' : currentTheme.button}`}
                      onKeyDown={e => {
                        if (editingKey === action) {
                          e.preventDefault()
                          setKeybindings(prev => ({ ...prev, [action]: e.key }))
                          setEditingKey(null)
                        }
                      }}
                    >
                      {editingKey === action ? '...' : formatKey(keybindings[action])}
                    </button>
                  </div>
                ))}
              </div>
              <div className="flex gap-2 mt-4">
                <button
                  onClick={() => { setKeybindings(DEFAULT_KEYBINDINGS); setEditingKey(null) }}
                  className={`flex-1 py-2 rounded-lg ${currentTheme.button}`}
                >
                  {t('actions.resetToDefault')}
                </button>
                <button
                  onClick={() => { setShowSettings(false); setEditingKey(null) }}
                  className={`flex-1 py-2 rounded-lg ${currentTheme.accent} text-white`}
                >
                  {t('actions.done')}
                </button>
              </div>
            </div>
          </div>
        )
      }

      window.path = { basename: filepath => filepath.split(/[\\/]/).pop() }
      ReactDOM.render(<I18nProvider><ImageViewerApp /></I18nProvider>, document.getElementById('root'))
    </script>
  </body>
</html>
